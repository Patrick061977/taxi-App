<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konflikt-Tester â€“ Live</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0f172a; color: #e2e8f0; min-height: 100vh; padding: 16px; }

        h1 { color: #fbbf24; font-size: 20px; margin-bottom: 4px; }
        .subtitle { color: #64748b; font-size: 13px; margin-bottom: 20px; }

        .card { background: #1e293b; border-radius: 12px; padding: 16px; margin-bottom: 16px; border: 1px solid #334155; }
        .card h2 { font-size: 14px; font-weight: 600; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px; }

        .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }

        label { display: block; font-size: 12px; color: #94a3b8; margin-bottom: 4px; }
        input, select { width: 100%; padding: 8px 10px; background: #0f172a; border: 1px solid #334155; border-radius: 8px; color: #e2e8f0; font-size: 14px; }
        input:focus, select:focus { outline: none; border-color: #fbbf24; }

        .param-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .param-row label { width: 200px; font-size: 13px; color: #cbd5e1; margin: 0; flex-shrink: 0; }
        .param-row input[type=range] { flex: 1; accent-color: #fbbf24; }
        .param-value { width: 55px; text-align: right; font-weight: 600; color: #fbbf24; font-size: 14px; }

        button { padding: 10px 20px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.15s; }
        .btn-primary { background: #fbbf24; color: #0f172a; }
        .btn-primary:hover { background: #f59e0b; }
        .btn-primary:disabled { background: #475569; color: #94a3b8; cursor: not-allowed; }
        .btn-secondary { background: #334155; color: #e2e8f0; }
        .btn-secondary:hover { background: #475569; }

        #status { font-size: 13px; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; display: none; }
        .status-ok { background: #064e3b; color: #6ee7b7; border: 1px solid #10b981; }
        .status-err { background: #7f1d1d; color: #fca5a5; border: 1px solid #ef4444; }
        .status-info { background: #1e3a5f; color: #93c5fd; border: 1px solid #3b82f6; }

        /* Ergebnis */
        #result { display: none; }
        .result-frei { border-left: 4px solid #10b981; background: #042f2e; }
        .result-konflikt { border-left: 4px solid #ef4444; background: #2d0d0d; }
        .result-warnung { border-left: 4px solid #f59e0b; background: #2d1f00; }
        .result-title { font-size: 20px; font-weight: 700; margin-bottom: 10px; }
        .result-frei .result-title { color: #10b981; }
        .result-konflikt .result-title { color: #ef4444; }
        .result-warnung .result-title { color: #f59e0b; }

        .detail-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #1e293b; font-size: 13px; }
        .detail-row:last-child { border: none; }
        .detail-label { color: #94a3b8; }
        .detail-value { font-weight: 600; color: #e2e8f0; }

        .alt-btn { display: inline-block; margin: 4px 4px 0 0; padding: 6px 14px; border-radius: 20px; font-size: 13px; font-weight: 600; cursor: pointer; border: none; }
        .alt-before { background: #92400e; color: #fde68a; }
        .alt-after  { background: #064e3b; color: #6ee7b7; }

        /* Fahrten-Tabelle */
        .rides-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 8px; }
        .rides-table th { text-align: left; color: #64748b; padding: 4px 8px; border-bottom: 1px solid #334155; }
        .rides-table td { padding: 5px 8px; border-bottom: 1px solid #1e293b; }
        .rides-table tr:hover td { background: #1e293b; }
        .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .badge-assigned { background: #92400e; color: #fde68a; }
        .badge-new      { background: #1e3a5f; color: #93c5fd; }
        .badge-other    { background: #334155; color: #94a3b8; }

        .log-box { background: #020617; border-radius: 8px; padding: 12px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 11px; margin-top: 10px; }
        .log-ok   { color: #6ee7b7; }
        .log-err  { color: #fca5a5; }
        .log-warn { color: #fde68a; }
        .log-info { color: #93c5fd; }
        .log-dim  { color: #475569; }

        .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid #475569; border-top-color: #fbbf24; border-radius: 50%; animation: spin 0.6s linear infinite; vertical-align: middle; margin-right: 6px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .tag { display: inline-block; padding: 1px 6px; border-radius: 4px; font-size: 11px; background: #334155; color: #94a3b8; margin-left: 4px; }

        .section-toggle { cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; }
        .section-toggle:hover h2 { color: #e2e8f0; }

        /* Karte */
        #map-card { display: none; }
        #map { height: 420px; border-radius: 8px; margin-top: 10px; border: 1px solid #334155; }

        /* Legende */
        .map-legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
        .legend-line { width: 24px; height: 3px; flex-shrink: 0; border-radius: 2px; }

        /* Leaflet popup dark */
        .leaflet-popup-content-wrapper { background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; }
        .leaflet-popup-tip { background: #1e293b; }
        .leaflet-popup-content { font-size: 12px; line-height: 1.5; }
        .popup-title { font-weight: 700; color: #fbbf24; margin-bottom: 4px; }
        .popup-conflict { color: #fca5a5; font-weight: 600; }
        .popup-ok { color: #6ee7b7; font-weight: 600; }
    </style>
</head>
<body>

<h1>ğŸš• Konflikt-Tester <span class="tag">Live</span></h1>
<p class="subtitle">Echte Firebase-Daten Â· Einstellbare Parameter Â· Direktes Testen Â· Kartenansicht</p>

<div id="status"></div>

<!-- PARAMETER -->
<div class="card">
    <div class="section-toggle" onclick="toggleSection('params')">
        <h2>âš™ï¸ Parameter</h2>
        <span id="params-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="params-body">
        <div class="param-row">
            <label>Einsteige-Zeit (boardingTime)</label>
            <input type="range" id="p-boarding" min="0" max="10" step="1" value="3" oninput="updateParam('boarding', this.value)">
            <span class="param-value" id="v-boarding">3 Min</span>
        </div>
        <div class="param-row">
            <label>Aussteige-Zeit (alightingTime)</label>
            <input type="range" id="p-alighting" min="0" max="10" step="1" value="2" oninput="updateParam('alighting', this.value)">
            <span class="param-value" id="v-alighting">2 Min</span>
        </div>
        <div class="param-row">
            <label>Sicherheits-Puffer (bufferTime)</label>
            <input type="range" id="p-buffer" min="0" max="20" step="1" value="5" oninput="updateParam('buffer', this.value)">
            <span class="param-value" id="v-buffer">5 Min</span>
        </div>
        <div class="param-row">
            <label>Waypoint-Stopzeit</label>
            <input type="range" id="p-waypoint" min="0" max="15" step="1" value="5" oninput="updateParam('waypoint', this.value)">
            <span class="param-value" id="v-waypoint">5 Min</span>
        </div>
        <div class="param-row">
            <label>Mindest-Abstand zwischen Fahrten</label>
            <input type="range" id="p-mindest" min="0" max="30" step="5" value="0" oninput="updateParam('mindest', this.value)">
            <span class="param-value" id="v-mindest">0 Min</span>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; font-size:12px; color:#64748b;">
            <button class="btn-secondary" style="padding:5px 12px; font-size:12px;" onclick="resetParams()">â†º ZurÃ¼cksetzen</button>
            <span>Standard-Werte: Einsteigen 3, Aussteigen 2, Puffer 5, Waypoint 5, Mindest 0</span>
        </div>
    </div>
</div>

<!-- EINGABE -->
<div class="card">
    <h2>ğŸ” Termin prÃ¼fen</h2>
    <div class="grid2" style="margin-bottom:10px;">
        <div>
            <label>Datum</label>
            <input type="date" id="in-date">
        </div>
        <div>
            <label>Uhrzeit</label>
            <input type="time" id="in-time" value="08:00">
        </div>
    </div>
    <div style="margin-bottom:10px;">
        <label>Abholadresse</label>
        <input type="text" id="in-pickup" placeholder="z.B. Amselring 10, Heringsdorf" value="Amselring 10, Heringsdorf">
    </div>
    <div style="margin-bottom:10px;">
        <label>Zieladresse</label>
        <input type="text" id="in-dest" placeholder="z.B. LabahnstraÃŸe 18, Heringsdorf" value="LabahnstraÃŸe 18, Heringsdorf">
    </div>
    <div class="grid2" style="margin-bottom:14px;">
        <div>
            <label>Passagiere</label>
            <select id="in-pax">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>
        </div>
        <div>
            <label>Zwischenstopps</label>
            <select id="in-waypoints">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
            </select>
        </div>
    </div>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn-primary" id="btn-check" onclick="runCheck()">â–¶ Konflikt prÃ¼fen</button>
        <button class="btn-secondary" onclick="loadRidesForDate()">ğŸ“… Fahrten laden</button>
        <button class="btn-secondary" onclick="openKalender()">ğŸ—“ï¸ Fahrtkalender</button>
        <button class="btn-secondary" onclick="fillFromLog()">ğŸ“‹ Beispiel: Log 02.03</button>
    </div>
</div>

<!-- FAHRTKALENDER -->
<div class="card" id="kalender-card" style="display:none;">
    <div class="section-toggle" onclick="toggleSection('kalender')">
        <h2>ğŸ—“ï¸ Fahrtkalender <span id="kalender-count" class="tag"></span></h2>
        <span id="kalender-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="kalender-body">
        <div id="kalender-content" style="margin-top:8px;"></div>
    </div>
</div>

<!-- ERGEBNIS -->
<div class="card" id="result">
    <h2>ğŸ“Š Ergebnis</h2>
    <div id="result-body"></div>
    <div id="log-output" class="log-box" style="display:none;"></div>
    <button class="btn-secondary" style="margin-top:8px; font-size:12px; padding:4px 10px;" onclick="toggleLog()">ğŸ” Debug-Log</button>
</div>

<!-- KARTE -->
<div class="card" id="map-card">
    <div class="section-toggle" onclick="toggleSection('map')">
        <h2>ğŸ—ºï¸ Kartenansicht</h2>
        <span id="map-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="map-body">
        <div id="map"></div>
        <div class="map-legend">
            <div class="legend-item">
                <div class="legend-line" style="background:#3b82f6;"></div>
                <span>Neue Fahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#94a3b8;"></div>
                <span>Bestehende Fahrten</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#ef4444;"></div>
                <span>Konflikt-Fahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#f59e0b; border-top: 2px dashed #f59e0b; height:0;"></div>
                <span>Leerfahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#3b82f6;"></div>
                <span>Abholung (neu)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#10b981;"></div>
                <span>Ziel (neu)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#fbbf24;"></div>
                <span>Bestehende Stops</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#ef4444;"></div>
                <span>Konflikt-Stop</span>
            </div>
        </div>
    </div>
</div>

<!-- FAHRTEN AM TAG -->
<div class="card" id="rides-card" style="display:none;">
    <div class="section-toggle" onclick="toggleSection('rides')">
        <h2>ğŸ“… Fahrten am gewÃ¤hlten Tag <span id="rides-date-label" class="tag"></span></h2>
        <span id="rides-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="rides-body">
        <table class="rides-table" id="rides-table">
            <thead><tr><th>Zeit</th><th>Von</th><th>Nach</th><th>Dauer</th><th>Status</th></tr></thead>
            <tbody id="rides-tbody"></tbody>
        </table>
    </div>
</div>

<!-- Firebase + Leaflet + Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
/* System-Analyse */
.analyse-section { margin-top: 16px; }
.analyse-header { font-weight: 700; font-size: 13px; text-transform: uppercase; letter-spacing: 0.04em; margin-bottom: 8px; }
.analyse-box { background: #0f172a; border-radius: 8px; padding: 12px; font-size: 12px; line-height: 1.7; margin-bottom: 10px; border: 1px solid #334155; }
.analyse-box.red   { border-color: #ef4444; background: #1a0505; }
.analyse-box.amber { border-color: #f59e0b; background: #1a1200; }
.analyse-box.green { border-color: #10b981; background: #011a10; }
.analyse-box.blue  { border-color: #3b82f6; background: #020d1a; }

.timing-row { display: flex; align-items: baseline; gap: 8px; padding: 3px 0; border-bottom: 1px solid #1e293b; }
.timing-row:last-child { border: none; }
.timing-label { color: #94a3b8; flex: 1; }
.timing-val   { font-weight: 700; color: #e2e8f0; min-width: 60px; text-align: right; }
.timing-sub   { font-size: 11px; color: #64748b; }

/* Timeline */
.timeline { margin: 12px 0; font-family: monospace; font-size: 11px; line-height: 1.6; }
.tl-row { display: flex; align-items: center; gap: 8px; padding: 2px 0; }
.tl-time  { width: 42px; text-align: right; color: #64748b; flex-shrink: 0; }
.tl-bar   { display: flex; align-items: center; gap: 4px; flex: 1; }
.tl-block { border-radius: 3px; padding: 2px 6px; font-size: 10px; font-weight: 600; white-space: nowrap; }
.tl-block.existing { background: #334155; color: #94a3b8; }
.tl-block.newride  { background: #1e3a5f; color: #93c5fd; border: 1px solid #3b82f6; }
.tl-block.conflict { background: #4c0519; color: #fca5a5; border: 1px solid #ef4444; }
.tl-block.deadhead { background: #422006; color: #fde68a; border: 1px dashed #f59e0b; }
.tl-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.tl-line { width: 1px; height: 12px; background: #334155; margin: 0 auto; }

/* Alt buttons */
.alt-section { margin-top: 14px; }
.alt-section h3 { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em; margin-bottom: 8px; }
.alt-grid { display: flex; flex-wrap: wrap; gap: 8px; }
.alt-btn-vor  { padding: 10px 16px; background: #422006; color: #fde68a; border: 2px solid #f59e0b; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer; transition: all 0.15s; }
.alt-btn-vor:hover  { background: #f59e0b; color: #0f172a; }
.alt-btn-nach { padding: 10px 16px; background: #011a10; color: #6ee7b7; border: 2px solid #10b981; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer; transition: all 0.15s; }
.alt-btn-nach:hover { background: #10b981; color: #0f172a; }

/* Kunden-Sicht */
.kunden-box { background: #020d1a; border: 2px solid #3b82f6; border-radius: 8px; padding: 14px; margin-bottom: 12px; }
.kunden-header { background: #3b82f6; color: white; font-weight: 700; font-size: 13px; text-align: center; padding: 8px; margin: -14px -14px 12px -14px; border-radius: 6px 6px 0 0; }

/* Separator */
.view-separator { border: none; border-top: 1px solid #334155; margin: 16px 0; }

/* Fahrtkalender */
.kal-month { margin-bottom: 16px; }
.kal-month-title { font-size: 13px; font-weight: 700; color: #fbbf24; margin-bottom: 8px; letter-spacing: 0.05em; }
.kal-days { display: flex; flex-wrap: wrap; gap: 6px; }
.kal-day { display: flex; flex-direction: column; align-items: center; padding: 8px 10px; background: #0f172a; border: 1px solid #334155; border-radius: 8px; cursor: pointer; transition: all 0.15s; min-width: 60px; }
.kal-day:hover { border-color: #fbbf24; background: #1e293b; }
.kal-day.today { border-color: #3b82f6; }
.kal-day.has-conflict { border-color: #ef4444; background: #1a0505; }
.kal-day-date { font-size: 13px; font-weight: 700; color: #e2e8f0; }
.kal-day-wd   { font-size: 10px; color: #64748b; }
.kal-day-cnt  { font-size: 11px; font-weight: 700; color: #fbbf24; margin-top: 2px; }
.kal-day-bar  { display: flex; gap: 2px; margin-top: 3px; flex-wrap: wrap; justify-content: center; }
.kal-dot { width: 5px; height: 5px; border-radius: 50%; background: #fbbf24; }
.kal-dot.assigned { background: #f59e0b; }
.kal-dot.new { background: #3b82f6; }

.kal-day-detail { display: none; }
.kal-day-list { margin-top: 10px; }
.kal-ride-row { display: flex; gap: 8px; align-items: flex-start; padding: 6px 0; border-bottom: 1px solid #1e293b; font-size: 12px; cursor: pointer; transition: background 0.1s; border-radius: 4px; }
.kal-ride-row:hover { background: #1e293b; }
.kal-ride-time { color: #fbbf24; font-weight: 700; min-width: 44px; flex-shrink: 0; }
.kal-ride-info { flex: 1; color: #94a3b8; }
.kal-ride-name { color: #e2e8f0; font-weight: 600; }
.kal-ride-btn { padding: 3px 8px; background: #334155; border: none; border-radius: 4px; color: #e2e8f0; font-size: 11px; cursor: pointer; }
.kal-ride-btn:hover { background: #fbbf24; color: #0f172a; }
</style>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIREBASE INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const FIREBASE_CONFIG = {
    apiKey: "AIzaSyD2eHFuplImxBCijd3MWlKyCwXUZHLmhhE",
    authDomain: "taxi-heringsdorf.firebaseapp.com",
    databaseURL: "https://taxi-heringsdorf-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "taxi-heringsdorf",
    storageBucket: "taxi-heringsdorf.firebasestorage.app"
};

let db = null;
let allRidesCache = {};
let logLines = [];

function showStatus(msg, type = 'info') {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = 'status-' + type;
    el.style.display = 'block';
}

async function initFirebase() {
    try {
        firebase.initializeApp(FIREBASE_CONFIG);
        db = firebase.database();
        showStatus('âœ… Firebase verbunden â€“ ' + FIREBASE_CONFIG.databaseURL, 'ok');
        log('âœ… Firebase bereit', 'ok');
    } catch(e) {
        showStatus('âŒ Firebase-Fehler: ' + e.message, 'err');
    }
}

initFirebase();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARAMETER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let params = { boarding: 3, alighting: 2, buffer: 5, waypoint: 5, mindest: 0 };

function updateParam(key, val) {
    params[key] = parseInt(val);
    document.getElementById('v-' + key).textContent = val + ' Min';
}

function resetParams() {
    const defaults = { boarding: 3, alighting: 2, buffer: 5, waypoint: 5, mindest: 0 };
    for (const [k, v] of Object.entries(defaults)) {
        params[k] = v;
        document.getElementById('p-' + k).value = v;
        document.getElementById('v-' + k).textContent = v + ' Min';
    }
    log('â†º Parameter auf Standard zurÃ¼ckgesetzt', 'info');
}

function totalDuration(driveMins, waypointCount = 0) {
    return driveMins + params.boarding + params.alighting + (waypointCount * params.waypoint);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOCODING (Nominatim)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const geocodeCache = {};

async function geocode(address) {
    if (geocodeCache[address]) return geocodeCache[address];
    try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', Usedom, Deutschland')}&limit=1&addressdetails=0`;
        const resp = await fetch(url, { headers: { 'Accept-Language': 'de' } });
        const data = await resp.json();
        if (data && data[0]) {
            const coords = { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
            geocodeCache[address] = coords;
            return coords;
        }
        // Fallback: ohne Usedom
        const url2 = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
        const resp2 = await fetch(url2);
        const data2 = await resp2.json();
        if (data2 && data2[0]) {
            const coords = { lat: parseFloat(data2[0].lat), lon: parseFloat(data2[0].lon) };
            geocodeCache[address] = coords;
            return coords;
        }
    } catch(e) {}
    return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTE (OSRM) â€“ mit Geometrie fÃ¼r Karte
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function calcRoute(from, to) {
    if (!from || !to) return { duration: 10, distance: 0, geometry: null };
    try {
        const url = `https://router.project-osrm.org/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=full&geometries=geojson`;
        const resp = await fetch(url);
        const data = await resp.json();
        if (data.routes && data.routes[0]) {
            return {
                duration: Math.ceil(data.routes[0].duration / 60),
                distance: +(data.routes[0].distance / 1000).toFixed(1),
                geometry: data.routes[0].geometry
            };
        }
    } catch(e) {}
    return { duration: 10, distance: 0, geometry: null };
}

// GeoJSON Koordinaten [lon,lat] â†’ Leaflet [lat,lon]
function geomToLatLngs(geometry) {
    if (!geometry || !geometry.coordinates) return [];
    return geometry.coordinates.map(c => [c[1], c[0]]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KARTE (Leaflet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let map = null;
let mapLayers = [];

function initMap() {
    if (map) return;
    map = L.map('map', { zoomControl: true }).setView([53.96, 14.07], 12);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OSM</a> Â© <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }).addTo(map);
}

function clearMapLayers() {
    mapLayers.forEach(l => map.removeLayer(l));
    mapLayers = [];
}

function addMapLayer(layer) {
    layer.addTo(map);
    mapLayers.push(layer);
}

function makeIcon(color, label = '') {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="36" viewBox="0 0 28 36">
        <path d="M14 0C6.27 0 0 6.27 0 14c0 9.33 14 22 14 22S28 23.33 28 14C28 6.27 21.73 0 14 0z" fill="${color}" stroke="#0f172a" stroke-width="2"/>
        <text x="14" y="18" text-anchor="middle" fill="white" font-size="9" font-weight="bold" font-family="sans-serif">${label}</text>
    </svg>`;
    return L.divIcon({
        html: svg,
        className: '',
        iconSize: [28, 36],
        iconAnchor: [14, 36],
        popupAnchor: [0, -36]
    });
}

async function renderMapAfterCheck(conflict, slotDateTime, pickupAddr, destAddr,
    pickupCoords, destCoords, newRouteGeom,
    prevRide, nextRide, dayRides,
    prevDestCoords, nextPickupCoords,
    deadheadPrevGeom, deadheadNextGeom) {

    document.getElementById('map-card').style.display = 'block';
    initMap();
    clearMapLayers();

    const bounds = [];
    let rideIndex = 0;

    // â”€â”€ Alle anderen Fahrten am Tag (grau) â”€â”€
    for (const r of dayRides) {
        rideIndex++;
        const isConflict = conflict && conflict.ride && conflict.ride.firebaseId === r.firebaseId;
        const isPrev = prevRide && prevRide.firebaseId === r.firebaseId;
        const isNext = nextRide && nextRide.firebaseId === r.firebaseId;

        const rPickupAddr = r.pickup || '';
        const rDestAddr   = r.destination || '';
        const rTs = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = rTs.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

        // Koordinaten aus Cache oder Geocoding
        let rFrom = r.pickupLat ? { lat: r.pickupLat, lon: r.pickupLon } : (r.pickupCoords || null);
        let rTo   = r.destLat   ? { lat: r.destLat,   lon: r.destLon   } : (r.destCoords   || null);
        if (!rFrom) rFrom = geocodeCache[rPickupAddr] || null;
        if (!rTo)   rTo   = geocodeCache[rDestAddr]   || null;

        const color = isConflict ? '#ef4444' : '#94a3b8';
        const iconColor = isConflict ? '#ef4444' : '#fbbf24';
        const weight = isConflict ? 4 : 2;
        const opacity = isConflict ? 0.9 : 0.5;

        const label = isConflict ? '!' : String(rideIndex);
        const roleStr = isConflict ? ' âš ï¸ KONFLIKT' : (isPrev ? ' (vorher)' : (isNext ? ' (nÃ¤chste)' : ''));

        const popupContent = `
            <div class="popup-title">${timeStr} Uhr${roleStr}</div>
            <div>${rPickupAddr}</div>
            <div style="color:#64748b;">â†“</div>
            <div>${rDestAddr}</div>
            <div style="margin-top:4px; color:#94a3b8;">${r.duration || r.estimatedDuration || '?'} Min | ${r.status}</div>
            ${isConflict ? `<div class="popup-conflict" style="margin-top:4px;">${conflict.msg}</div>` : ''}
        `;

        if (rFrom) {
            const m = L.marker([rFrom.lat, rFrom.lon], { icon: makeIcon(iconColor, label) })
                .bindPopup(popupContent);
            addMapLayer(m);
            bounds.push([rFrom.lat, rFrom.lon]);
        }
        if (rTo) {
            const mTo = L.marker([rTo.lat, rTo.lon], { icon: makeIcon(isConflict ? '#ef4444' : '#475569', 'â—') })
                .bindPopup(popupContent);
            addMapLayer(mTo);
            bounds.push([rTo.lat, rTo.lon]);
        }

        // Route der bestehenden Fahrt (falls Koordinaten bekannt)
        if (rFrom && rTo) {
            try {
                const rt = await calcRoute(rFrom, rTo);
                if (rt.geometry) {
                    const pl = L.polyline(geomToLatLngs(rt.geometry), {
                        color, weight, opacity
                    }).bindPopup(popupContent);
                    addMapLayer(pl);
                }
            } catch(e) {}
        }
    }

    // â”€â”€ Leerfahrt VOR neuer Fahrt (orange gestrichelt) â”€â”€
    if (deadheadPrevGeom) {
        const pl = L.polyline(geomToLatLngs(deadheadPrevGeom), {
            color: '#f59e0b', weight: 2, opacity: 0.8,
            dashArray: '6 6'
        }).bindPopup('<div class="popup-title" style="color:#f59e0b;">Leerfahrt (vorher)</div>');
        addMapLayer(pl);
    }

    // â”€â”€ Leerfahrt NACH neuer Fahrt (orange gestrichelt) â”€â”€
    if (deadheadNextGeom) {
        const pl = L.polyline(geomToLatLngs(deadheadNextGeom), {
            color: '#f59e0b', weight: 2, opacity: 0.8,
            dashArray: '6 6'
        }).bindPopup('<div class="popup-title" style="color:#f59e0b;">Leerfahrt (danach)</div>');
        addMapLayer(pl);
    }

    // â”€â”€ Neue Fahrt (blau, dick) â”€â”€
    const newEndTs = slotDateTime.getTime() + totalDuration(0, 0) * 60000;
    const newTimeStr = slotDateTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    const newPopup = `
        <div class="popup-title" style="color:#3b82f6;">ğŸ†• Neue Fahrt â€“ ${newTimeStr} Uhr</div>
        <div>${pickupAddr}</div>
        <div style="color:#64748b;">â†“</div>
        <div>${destAddr}</div>
        ${conflict ? `<div class="popup-conflict" style="margin-top:4px;">âŒ ${conflict.msg}</div>` :
                     `<div class="popup-ok" style="margin-top:4px;">âœ… Slot frei</div>`}
    `;

    if (newRouteGeom) {
        const pl = L.polyline(geomToLatLngs(newRouteGeom), {
            color: '#3b82f6', weight: 5, opacity: 0.9
        }).bindPopup(newPopup);
        addMapLayer(pl);
    }

    if (pickupCoords) {
        const m = L.marker([pickupCoords.lat, pickupCoords.lon], { icon: makeIcon('#3b82f6', 'A') })
            .bindPopup(`<div class="popup-title" style="color:#3b82f6;">Abholung (neu)</div><div>${pickupAddr}</div>`);
        addMapLayer(m);
        bounds.push([pickupCoords.lat, pickupCoords.lon]);
    }

    if (destCoords) {
        const m = L.marker([destCoords.lat, destCoords.lon], { icon: makeIcon('#10b981', 'Z') })
            .bindPopup(`<div class="popup-title" style="color:#10b981;">Ziel (neu)</div><div>${destAddr}</div>`);
        addMapLayer(m);
        bounds.push([destCoords.lat, destCoords.lon]);
    }

    // Karte auf alle Punkte zoomen
    if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [30, 30] });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function log(msg, type = 'dim') {
    logLines.push({ msg, type });
    const box = document.getElementById('log-output');
    if (box.style.display !== 'none') renderLog();
}

function renderLog() {
    const box = document.getElementById('log-output');
    box.innerHTML = logLines.map(l =>
        `<div class="log-${l.type}">${l.msg}</div>`
    ).join('');
    box.scrollTop = box.scrollHeight;
}

let logVisible = false;
function toggleLog() {
    logVisible = !logVisible;
    const box = document.getElementById('log-output');
    box.style.display = logVisible ? 'block' : 'none';
    if (logVisible) renderLog();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAHRTEN LADEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getLocalDateString(date) {
    return date.getFullYear() + '-' +
        String(date.getMonth() + 1).padStart(2, '0') + '-' +
        String(date.getDate()).padStart(2, '0');
}

async function loadRidesForDate() {
    const dateStr = document.getElementById('in-date').value;
    if (!dateStr) { showStatus('âš ï¸ Bitte Datum wÃ¤hlen', 'err'); return; }
    if (!db) { showStatus('âš ï¸ Firebase nicht verbunden', 'err'); return; }

    showStatus('â³ Lade Fahrten...', 'info');
    log(`ğŸ“… Lade Fahrten fÃ¼r ${dateStr}...`, 'info');

    try {
        const snap = await db.ref('rides').once('value');
        allRidesCache = snap.val() || {};

        const skipStatus = ['cancelled', 'storniert', 'completed', 'abgeschlossen'];
        const skipSource = ['hotel_calendar_import'];

        const ridesOnDay = Object.entries(allRidesCache)
            .filter(([id, r]) => {
                if (skipStatus.includes(r.status)) return false;
                if (skipSource.includes(r.source)) return false;
                const ts = r.pickupTimestamp || r.pickupTime;
                if (!ts) return false;
                const d = new Date(ts);
                return getLocalDateString(d) === dateStr;
            })
            .map(([id, r]) => ({ ...r, firebaseId: id }))
            .sort((a, b) => {
                const ta = new Date(a.pickupTimestamp || a.pickupTime).getTime();
                const tb = new Date(b.pickupTimestamp || b.pickupTime).getTime();
                return ta - tb;
            });

        renderRidesTable(ridesOnDay, dateStr);
        showStatus(`âœ… ${ridesOnDay.length} Fahrt(en) am ${dateStr} geladen (${Object.keys(allRidesCache).length} gesamt)`, 'ok');
        log(`âœ… ${ridesOnDay.length} Fahrt(en) am ${dateStr}`, 'ok');

        // Karte nur mit Tagesfahrten anzeigen
        await renderMapDayOnly(ridesOnDay);
    } catch(e) {
        showStatus('âŒ Fehler: ' + e.message, 'err');
        log('âŒ ' + e.message, 'err');
    }
}

async function renderMapDayOnly(rides) {
    document.getElementById('map-card').style.display = 'block';
    initMap();
    clearMapLayers();
    const bounds = [];

    for (let i = 0; i < rides.length; i++) {
        const r = rides[i];
        const rTs = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = rTs.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

        let rFrom = r.pickupLat ? { lat: r.pickupLat, lon: r.pickupLon } : null;
        let rTo   = r.destLat   ? { lat: r.destLat,   lon: r.destLon   } : null;
        if (!rFrom && r.pickup)      rFrom = await geocode(r.pickup);
        if (!rTo   && r.destination) rTo   = await geocode(r.destination);

        const popupContent = `
            <div class="popup-title">${timeStr} Uhr â€“ Fahrt ${i+1}</div>
            <div>${r.pickup || '?'}</div>
            <div style="color:#64748b;">â†“</div>
            <div>${r.destination || '?'}</div>
            <div style="margin-top:4px; color:#94a3b8;">${r.duration || '?'} Min | ${r.status}</div>
        `;

        if (rFrom) {
            addMapLayer(L.marker([rFrom.lat, rFrom.lon], { icon: makeIcon('#fbbf24', String(i+1)) }).bindPopup(popupContent));
            bounds.push([rFrom.lat, rFrom.lon]);
        }
        if (rTo) {
            addMapLayer(L.marker([rTo.lat, rTo.lon], { icon: makeIcon('#475569', 'â—') }).bindPopup(popupContent));
            bounds.push([rTo.lat, rTo.lon]);
        }
        if (rFrom && rTo) {
            const rt = await calcRoute(rFrom, rTo);
            if (rt.geometry) {
                addMapLayer(L.polyline(geomToLatLngs(rt.geometry), {
                    color: '#94a3b8', weight: 2, opacity: 0.6
                }).bindPopup(popupContent));
            }
        }
    }

    if (bounds.length > 0) map.fitBounds(bounds, { padding: [30, 30] });
}

function renderRidesTable(rides, dateStr) {
    document.getElementById('rides-card').style.display = 'block';
    document.getElementById('rides-date-label').textContent = dateStr;

    const tbody = document.getElementById('rides-tbody');
    if (rides.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="color:#64748b; padding:12px;">Keine aktiven Fahrten an diesem Tag</td></tr>';
        return;
    }
    tbody.innerHTML = rides.map(r => {
        const t = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = t.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
        const dur = r.duration || r.estimatedDuration || '?';
        const statusClass = r.status === 'assigned' ? 'assigned' : (r.status === 'new' ? 'new' : 'other');
        const pickup = (r.pickup || '').substring(0, 25) + ((r.pickup || '').length > 25 ? 'â€¦' : '');
        const dest   = (r.destination || '').substring(0, 25) + ((r.destination || '').length > 25 ? 'â€¦' : '');
        return `<tr>
            <td style="font-weight:600; color:#fbbf24;">${timeStr}</td>
            <td>${pickup}</td>
            <td>${dest}</td>
            <td>${dur} Min</td>
            <td><span class="badge badge-${statusClass}">${r.status}</span></td>
        </tr>`;
    }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALTERNATIVE SLOTS â€“ VORHER & NACHHER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/** PrÃ¼ft ob ein Slot frei ist (keine Ãœberschneidung mit bestehenden Fahrten + Puffer) */
function isSlotFree(startMs, newTotalMins, dayRides) {
    const durationMs = newTotalMins * 60000;
    const bufMs = params.buffer * 60000;
    for (const r of dayRides) {
        const rStart = new Date(r.pickupTimestamp || r.pickupTime).getTime();
        const rDurMins = totalDuration(r.duration || r.estimatedDuration || 20, 0);
        const rEnd = rStart + rDurMins * 60000;
        // Ãœberlapp inkl. Puffer
        if (startMs < rEnd + bufMs && (startMs + durationMs) + bufMs > rStart) return false;
    }
    return true;
}

/** VORHER-Alternativen: Findet Slots BEVOR dem gewÃ¼nschten Zeitpunkt */
function findBeforeAlts(slotTs, newTotalMins, dayRides) {
    // SpÃ¤testmÃ¶glicher Start: Slot-Start - neue Fahrtdauer - Puffer
    const latestMs = slotTs - newTotalMins * 60000 - params.buffer * 60000;
    const latestRounded = Math.floor(latestMs / (5 * 60000)) * (5 * 60000);

    const alts = [];
    // Suche ab spÃ¤testem Start rÃ¼ckwÃ¤rts (bis 90 Min frÃ¼her)
    for (let t = latestRounded; t >= latestRounded - 90 * 60000; t -= 5 * 60000) {
        if (isSlotFree(t, newTotalMins, dayRides)) {
            const d = new Date(t);
            alts.push(d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }));
            if (alts.length >= 1) break; // Nur spÃ¤testmÃ¶glicher Vorher-Slot
        }
    }
    return alts; // [0] = spÃ¤testmÃ¶glich VORHER
}

/** NACHHER-Alternativen: Findet Slots NACH dem frÃ¼hestmÃ¶glichen Zeitpunkt */
function findAfterAlts(earliestMs, newTotalMins, dayRides) {
    const startRounded = Math.ceil(earliestMs / (5 * 60000)) * (5 * 60000);
    const alts = [];
    for (let t = startRounded; t <= startRounded + 120 * 60000; t += 5 * 60000) {
        if (isSlotFree(t, newTotalMins, dayRides)) {
            const d = new Date(t);
            alts.push(d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }));
            if (alts.length >= 4) break;
        }
    }
    return alts;
}

function fmtTime(ts) {
    return new Date(ts).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KONFLIKT-PRÃœFUNG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function runCheck() {
    const dateStr = document.getElementById('in-date').value;
    const timeStr = document.getElementById('in-time').value;
    const pickupAddr = document.getElementById('in-pickup').value.trim();
    const destAddr   = document.getElementById('in-dest').value.trim();
    const waypointCount = parseInt(document.getElementById('in-waypoints').value);

    if (!dateStr || !timeStr || !pickupAddr || !destAddr) {
        showStatus('âš ï¸ Bitte alle Felder ausfÃ¼llen', 'err'); return;
    }
    if (!db) { showStatus('âš ï¸ Firebase nicht verbunden', 'err'); return; }

    const btn = document.getElementById('btn-check');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>PrÃ¼feâ€¦';
    logLines = [];
    document.getElementById('result').style.display = 'none';
    showStatus('â³ Koordinaten & Routen werden berechnetâ€¦', 'info');

    const slotDateTime = new Date(`${dateStr}T${timeStr}:00`);
    log(`ğŸ” PrÃ¼fe: ${slotDateTime.toLocaleString('de-DE')}`, 'info');
    log(`ğŸ“ ${pickupAddr} â†’ ${destAddr}`, 'info');
    log(`âš™ï¸ boarding=${params.boarding} alighting=${params.alighting} buffer=${params.buffer} waypoints=${waypointCount}Ã—${params.waypoint} mindest=${params.mindest}`, 'dim');

    // FÃ¼r Karte merken
    let deadheadPrevGeom = null;
    let deadheadNextGeom = null;
    let prevDestCoordsForMap = null;
    let nextPickupCoordsForMap = null;

    try {
        // 1. Firebase laden falls noch nicht
        if (Object.keys(allRidesCache).length === 0) {
            log('ğŸ“¡ Lade Firebaseâ€¦', 'info');
            const snap = await db.ref('rides').once('value');
            allRidesCache = snap.val() || {};
            log(`âœ… ${Object.keys(allRidesCache).length} Fahrten geladen`, 'ok');
        }

        // 2. Relevante Fahrten filtern (gleicher Tag, aktiv)
        const skipStatus = ['cancelled', 'storniert', 'completed', 'abgeschlossen'];
        const slotDateStr = getLocalDateString(slotDateTime);
        const slotTs = slotDateTime.getTime();

        const dayRides = Object.entries(allRidesCache)
            .filter(([id, r]) => {
                if (skipStatus.includes(r.status)) return false;
                if (r.source === 'hotel_calendar_import' || r.hotelCalendarId) return false;
                const ts = r.pickupTimestamp || r.pickupTime;
                if (!ts) return false;
                return getLocalDateString(new Date(ts)) === slotDateStr;
            })
            .map(([id, r]) => ({ ...r, firebaseId: id }))
            .sort((a, b) => new Date(a.pickupTimestamp||a.pickupTime) - new Date(b.pickupTimestamp||b.pickupTime));

        log(`ğŸ“… ${dayRides.length} aktive Fahrt(en) am ${slotDateStr}`, 'info');
        dayRides.forEach(r => {
            const t = new Date(r.pickupTimestamp || r.pickupTime);
            log(`   ${t.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} | ${r.pickup||'?'} â†’ ${r.destination||'?'} | ${r.duration||'?'} Min | ${r.status}`, 'dim');
        });

        // 3. Geocoding
        log('ğŸŒ Geocodiere Adressenâ€¦', 'info');
        const [pickupCoords, destCoords] = await Promise.all([geocode(pickupAddr), geocode(destAddr)]);
        if (!pickupCoords) { showStatus('âŒ Abholadresse nicht gefunden', 'err'); btn.disabled=false; btn.textContent='â–¶ Konflikt prÃ¼fen'; return; }
        if (!destCoords)   { showStatus('âŒ Zieladresse nicht gefunden',  'err'); btn.disabled=false; btn.textContent='â–¶ Konflikt prÃ¼fen'; return; }
        log(`âœ… Pickup: ${pickupCoords.lat.toFixed(4)}, ${pickupCoords.lon.toFixed(4)}`, 'ok');
        log(`âœ… Dest:   ${destCoords.lat.toFixed(4)}, ${destCoords.lon.toFixed(4)}`, 'ok');

        // 4. Neue Fahrt-Dauer berechnen
        log('ğŸ—ºï¸ Berechne Route der neuen Fahrt (OSRM)â€¦', 'info');
        const newRoute = await calcRoute(pickupCoords, destCoords);
        const newDriveMins = newRoute.duration;
        const newTotalMins = totalDuration(newDriveMins, waypointCount);
        const newEndTs = slotTs + newTotalMins * 60000;
        log(`ğŸš— Fahrtdauer: ${newDriveMins} Min | Gesamt: ${newTotalMins} Min (Ende: ${new Date(newEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})})`, 'ok');

        // 5. Vorherige Fahrt finden
        let prevRide = null;
        for (let i = dayRides.length - 1; i >= 0; i--) {
            const r = dayRides[i];
            const rTs = new Date(r.pickupTimestamp || r.pickupTime).getTime();
            if (rTs < slotTs) { prevRide = r; break; }
        }

        // 6. NÃ¤chste Fahrt finden
        let nextRide = null;
        for (const r of dayRides) {
            const rTs = new Date(r.pickupTimestamp || r.pickupTime).getTime();
            if (rTs > slotTs) { nextRide = r; break; }
        }

        // 7. Exakte Ãœberschneidung
        const exactOverlap = dayRides.find(r => new Date(r.pickupTimestamp || r.pickupTime).getTime() === slotTs);

        // â”€â”€ PRÃœFUNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let conflict = null;

        // A) Exakte ZeitÃ¼berschneidung
        if (exactOverlap) {
            conflict = { type: 'exact', ride: exactOverlap, msg: 'Exakt gleiche Uhrzeit bereits gebucht' };
            log('ğŸš¨ EXAKTE ZEITÃœBERSCHNEIDUNG!', 'err');
        }

        // B) Neuer Slot liegt wÃ¤hrend vorheriger Fahrt
        if (!conflict && prevRide) {
            const prevTs = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).getTime();
            const prevDur = totalDuration(prevRide.duration || prevRide.estimatedDuration || 20, 0);
            const prevEndTs = prevTs + prevDur * 60000;
            if (slotTs < prevEndTs) {
                conflict = { type: 'during', ride: prevRide, rideEnd: prevEndTs, msg: 'Taxi ist noch unterwegs' };
                log(`ğŸš¨ WÃ„HREND LAUFENDER FAHRT: ${new Date(prevTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} â€“ ${new Date(prevEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'err');
            }
        }

        // C) Zu wenig Zeit nach vorheriger Fahrt (Leerfahrt)
        if (!conflict && prevRide) {
            const prevTs = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).getTime();
            const prevDur = totalDuration(prevRide.duration || prevRide.estimatedDuration || 20, 0);
            const prevEndTs = prevTs + prevDur * 60000;
            if (slotTs >= prevEndTs) {
                log(`ğŸ—ºï¸ Leerfahrt: ${prevRide.destination||'?'} â†’ ${pickupAddr}`, 'info');
                let prevDestCoords = null;
                if (prevRide.destLat && prevRide.destLon) prevDestCoords = { lat: prevRide.destLat, lon: prevRide.destLon };
                else if (prevRide.destCoords) prevDestCoords = prevRide.destCoords;
                else prevDestCoords = await geocode(prevRide.destination);
                prevDestCoordsForMap = prevDestCoords;

                const deadhead = prevDestCoords ? await calcRoute(prevDestCoords, pickupCoords) : { duration: params.buffer + 5, geometry: null };
                deadheadPrevGeom = deadhead.geometry;
                const minGap = Math.max(deadhead.duration + params.buffer, params.mindest);
                const earliestTs = prevEndTs + minGap * 60000;
                const gapMin = Math.round((slotTs - prevEndTs) / 60000);
                const reserveMin = Math.round((slotTs - earliestTs) / 60000);

                log(`   Vorh. Fahrt endet: ${new Date(prevEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'dim');
                log(`   Leerfahrt: ${deadhead.duration} Min + Puffer: ${params.buffer} Min = ${minGap} Min benÃ¶tigt`, 'dim');
                log(`   LÃ¼cke: ${gapMin} Min | Reserve: ${reserveMin} Min`, reserveMin < 0 ? 'err' : (reserveMin === 0 ? 'warn' : 'ok'));

                if (slotTs < earliestTs) {
                    conflict = { type: 'prev_gap', ride: prevRide, deadhead: deadhead.duration, earliestTs, reserveMin,
                        msg: `Zu wenig Zeit nach vorheriger Fahrt (${Math.abs(reserveMin)} Min fehlen)` };
                    log('ğŸš¨ ZU WENIG ZEIT NACH VORHERIGER FAHRT', 'err');
                }
            }
        }

        // D) Neue Fahrt endet zu spÃ¤t fÃ¼r nÃ¤chste Fahrt
        if (!conflict && nextRide) {
            const nextTs = new Date(nextRide.pickupTimestamp || nextRide.pickupTime).getTime();
            log(`ğŸ—ºï¸ Leerfahrt zur nÃ¤chsten: ${destAddr} â†’ ${nextRide.pickup||'?'}`, 'info');
            let nextPickupCoords = null;
            if (nextRide.pickupLat && nextRide.pickupLon) nextPickupCoords = { lat: nextRide.pickupLat, lon: nextRide.pickupLon };
            else if (nextRide.pickupCoords) nextPickupCoords = nextRide.pickupCoords;
            else nextPickupCoords = await geocode(nextRide.pickup);
            nextPickupCoordsForMap = nextPickupCoords;

            const deadhead2 = nextPickupCoords ? await calcRoute(destCoords, nextPickupCoords) : { duration: params.buffer + 5, geometry: null };
            deadheadNextGeom = deadhead2.geometry;
            const neededGap = Math.max(deadhead2.duration + params.buffer, params.mindest);
            const earliestForNext = newEndTs + neededGap * 60000;
            const timeUntilNext = Math.round((nextTs - newEndTs) / 60000);
            const reserveNext = Math.round((nextTs - earliestForNext) / 60000);

            log(`   Neue Fahrt endet: ${new Date(newEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'dim');
            log(`   Leerfahrt: ${deadhead2.duration} Min + Puffer: ${params.buffer} Min = ${neededGap} Min benÃ¶tigt`, 'dim');
            log(`   NÃ¤chste Fahrt: ${new Date(nextTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} | Reserve: ${reserveNext} Min`, reserveNext <= 0 ? (reserveNext < 0 ? 'err' : 'warn') : 'ok');

            if (earliestForNext >= nextTs) {
                const latestStartMs = nextTs - (newTotalMins + deadhead2.duration + params.buffer) * 60000;
                const latestRounded = (Math.floor(latestStartMs / (5 * 60000)) - 1) * (5 * 60000);
                const beforeAlt = latestRounded > 0 ? new Date(latestRounded) : null;
                conflict = { type: 'next_gap', ride: nextRide, deadhead: deadhead2.duration, neededGap, timeUntilNext, reserveNext, beforeAlt,
                    msg: `Taxi kommt nicht rechtzeitig zur nÃ¤chsten Fahrt (${Math.abs(reserveNext)} Min zu wenig)` };
                log('ğŸš¨ ZU WENIG ZEIT VOR NÃ„CHSTER FAHRT', 'err');
                if (beforeAlt) log(`   VORHER-Alternative: ${beforeAlt.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} Uhr`, 'warn');
            } else {
                log(`âœ… NÃ¤chste Fahrt: ${reserveNext} Min Reserve`, 'ok');
            }
        }

        // 8. Alternativen berechnen
        let beforeAlts = [];
        let afterAlts  = [];

        if (conflict) {
            // VORHER: Nur bei next_gap oder exact sinnvoll
            if (conflict.type === 'next_gap') {
                // beforeAlt bereits oben berechnet â†’ in findBeforeAlts verpacken
                if (conflict.beforeAlt) {
                    beforeAlts = [conflict.beforeAlt.toLocaleTimeString('de-DE', {hour:'2-digit',minute:'2-digit'})];
                }
            } else if (conflict.type === 'exact' || conflict.type === 'during') {
                // SpÃ¤testmÃ¶glicher Slot vor dem Konflikt
                beforeAlts = findBeforeAlts(slotTs, newTotalMins, dayRides);
            }

            // NACHHER: FrÃ¼hestmÃ¶glicher Start nach dem Konflikt
            let earliestAfterMs = null;

            if (conflict.type === 'prev_gap' && conflict.earliestTs) {
                earliestAfterMs = conflict.earliestTs;
            } else if (conflict.type === 'during' && prevRide) {
                const prevTs2 = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).getTime();
                const prevDur2 = totalDuration(prevRide.duration || prevRide.estimatedDuration || 20, 0);
                const prevEnd2 = prevTs2 + prevDur2 * 60000;
                // deadhead from prevRide.destination â†’ pickupAddr
                let pDestCoords2 = prevDestCoordsForMap;
                if (!pDestCoords2) pDestCoords2 = await geocode(prevRide.destination);
                const dh2 = pDestCoords2 ? await calcRoute(pDestCoords2, pickupCoords) : { duration: params.buffer + 5 };
                earliestAfterMs = prevEnd2 + (dh2.duration + params.buffer) * 60000;
            } else if (conflict.type === 'exact' && conflict.ride) {
                const cTs = new Date(conflict.ride.pickupTimestamp || conflict.ride.pickupTime).getTime();
                const cDur = totalDuration(conflict.ride.duration || conflict.ride.estimatedDuration || 20, 0);
                const cEnd = cTs + cDur * 60000;
                let cDestCoords = await geocode(conflict.ride.destination);
                const dhC = cDestCoords ? await calcRoute(cDestCoords, pickupCoords) : { duration: params.buffer + 5 };
                earliestAfterMs = cEnd + (dhC.duration + params.buffer) * 60000;
            } else if (conflict.type === 'next_gap' && nextRide) {
                const nTs = new Date(nextRide.pickupTimestamp || nextRide.pickupTime).getTime();
                const nDur = totalDuration(nextRide.duration || nextRide.estimatedDuration || 20, 0);
                const nEnd = nTs + nDur * 60000;
                let nDestCoords = await geocode(nextRide.destination);
                const dhN = nDestCoords ? await calcRoute(nDestCoords, pickupCoords) : { duration: params.buffer + 5 };
                earliestAfterMs = nEnd + (dhN.duration + params.buffer) * 60000;
            }

            if (earliestAfterMs) {
                afterAlts = findAfterAlts(earliestAfterMs, newTotalMins, dayRides);
                log(`ğŸŸ¢ NACHHER: ${afterAlts.length} Alternativen ab ${fmtTime(earliestAfterMs)}`, 'ok');
            }
            log(`ğŸ”¶ VORHER: ${beforeAlts.length > 0 ? beforeAlts[0] + ' Uhr (spÃ¤testens)' : 'nicht mÃ¶glich'}`, beforeAlts.length > 0 ? 'warn' : 'dim');
        }

        // 9. Ergebnis anzeigen
        showResult(conflict, slotDateTime, pickupAddr, destAddr, newDriveMins, newTotalMins,
            prevRide, nextRide, dayRides, beforeAlts, afterAlts,
            prevDestCoordsForMap, nextPickupCoordsForMap);
        renderRidesTable(dayRides, slotDateStr);
        showStatus(conflict ? `âŒ KONFLIKT: ${conflict.msg}` : 'âœ… SLOT FREI', conflict ? 'err' : 'ok');

        // 10. Karte rendern
        await renderMapAfterCheck(
            conflict, slotDateTime, pickupAddr, destAddr,
            pickupCoords, destCoords, newRoute.geometry,
            prevRide, nextRide, dayRides,
            prevDestCoordsForMap, nextPickupCoordsForMap,
            deadheadPrevGeom, deadheadNextGeom
        );

    } catch(e) {
        showStatus('âŒ Fehler: ' + e.message, 'err');
        log('âŒ Fehler: ' + e.message, 'err');
        console.error(e);
    }

    btn.disabled = false;
    btn.textContent = 'â–¶ Konflikt prÃ¼fen';
}

function showResult(conflict, slotDt, pickup, dest, driveMins, totalMins,
    prevRide, nextRide, dayRides, beforeAlts, afterAlts) {

    const el = document.getElementById('result');
    const body = document.getElementById('result-body');
    el.style.display = 'block';

    const slotTs  = slotDt.getTime();
    const slotEnd = new Date(slotTs + totalMins * 60000);
    const timeStr = slotDt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    const endStr  = slotEnd.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

    el.className = conflict ? 'card result-konflikt' : 'card result-frei';

    let html = '';

    // â”€â”€ Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!conflict) {
        html += `<div class="result-title">âœ… SLOT FREI</div>`;
        html += `<div class="detail-row"><span class="detail-label">Slot</span><span class="detail-value">${slotDt.toLocaleDateString('de-DE')} ${timeStr}â€“${endStr} Uhr</span></div>`;
        html += `<div class="detail-row"><span class="detail-label">Strecke</span><span class="detail-value">${pickup} â†’ ${dest}</span></div>`;
        html += `<div class="detail-row"><span class="detail-label">Fahrtdauer</span><span class="detail-value">${driveMins} Min + ${params.boarding+params.alighting} Min Ein/Aus = <strong>${totalMins} Min</strong></span></div>`;
        html += `<div class="detail-row"><span class="detail-label">Fahrten am Tag</span><span class="detail-value">${dayRides.length}</span></div>`;
        if (prevRide) {
            const pt = fmtTime(new Date(prevRide.pickupTimestamp||prevRide.pickupTime).getTime());
            const prevDurTotal = totalDuration(prevRide.duration||prevRide.estimatedDuration||20, 0);
            const prevEnd = fmtTime(new Date(prevRide.pickupTimestamp||prevRide.pickupTime).getTime() + prevDurTotal*60000);
            html += `<div class="detail-row"><span class="detail-label">Vorherige Fahrt</span><span class="detail-value">${pt}â€“${prevEnd} Uhr</span></div>`;
        }
        if (nextRide) {
            const nt = fmtTime(new Date(nextRide.pickupTimestamp||nextRide.pickupTime).getTime());
            html += `<div class="detail-row"><span class="detail-label">NÃ¤chste Fahrt</span><span class="detail-value">ab ${nt} Uhr</span></div>`;
        }
        body.innerHTML = html;
        return;
    }

    // â”€â”€ KONFLIKT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="result-title">âŒ KONFLIKT</div>`;

    // â”€â”€ 1. KUNDEN-SICHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="kunden-box">`;
    html += `<div class="kunden-header">ğŸ‘¤ KUNDEN-SICHT â€“ Was der Kunde sieht</div>`;
    html += `<div style="text-align:center; padding:10px 0 6px;">`;
    html += `<div style="font-size:28px; margin-bottom:6px;">âŒ</div>`;
    html += `<div style="font-size:15px; font-weight:700; color:#f59e0b; margin-bottom:4px;">Termin nicht verfÃ¼gbar</div>`;
    html += `<div style="font-size:13px; color:#64748b;">${slotDt.toLocaleDateString('de-DE', {weekday:'short', day:'2-digit', month:'2-digit', year:'numeric'})}</div>`;
    html += `<div style="font-size:13px; color:#64748b;">${timeStr} Uhr ist bereits belegt</div>`;
    html += `</div>`;

    // Alternativen in Kunden-Sicht
    if (beforeAlts.length > 0 || afterAlts.length > 0) {
        html += `<hr class="view-separator">`;
        if (beforeAlts.length > 0) {
            html += `<div style="font-size:12px; color:#fde68a; font-weight:700; margin-bottom:6px;">ğŸ”¶ VORHER noch mÃ¶glich (spÃ¤testens):</div>`;
            html += `<div class="alt-grid">`;
            beforeAlts.forEach(t => {
                html += `<button class="alt-btn-vor" onclick="fillTime('${t}')">â¬… ${t} Uhr</button>`;
            });
            html += `</div>`;
        }
        if (afterAlts.length > 0) {
            html += `<div style="font-size:12px; color:#6ee7b7; font-weight:700; margin:10px 0 6px;">âœ… NACHHER frÃ¼hestens mÃ¶glich:</div>`;
            html += `<div class="alt-grid">`;
            afterAlts.forEach(t => {
                html += `<button class="alt-btn-nach" onclick="fillTime('${t}')">â–¶ ${t} Uhr</button>`;
            });
            html += `</div>`;
        }
    }
    html += `</div>`; // end kunden-box

    // â”€â”€ 2. SYSTEM-ANALYSE (Admin-Sicht) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<hr class="view-separator">`;
    html += `<div class="analyse-section">`;
    html += `<div class="analyse-header" style="color:#f59e0b;">ğŸ” SYSTEM-ANALYSE (Admin-Sicht)</div>`;

    // Neue Fahrt Details
    html += `<div class="analyse-box blue">`;
    html += `<div style="color:#93c5fd; font-weight:700; margin-bottom:6px;">ğŸ†• Neue Fahrt (Anfrage)</div>`;
    html += `<div class="timing-row"><span class="timing-label">Wunschzeit</span><span class="timing-val">${timeStr} Uhr</span></div>`;
    html += `<div class="timing-row"><span class="timing-label">Strecke</span><span class="timing-val" style="font-size:11px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:180px;">${pickup} â†’ ${dest}</span></div>`;
    html += `<div class="timing-row"><span class="timing-label">Fahrtdauer (OSRM)</span><span class="timing-val">${driveMins} Min</span></div>`;
    html += `<div class="timing-row"><span class="timing-label">+ Einsteigen</span><span class="timing-val">${params.boarding} Min</span></div>`;
    html += `<div class="timing-row"><span class="timing-label">+ Aussteigen</span><span class="timing-val">${params.alighting} Min</span></div>`;
    html += `<div class="timing-row" style="border-top:1px solid #3b82f6; padding-top:4px; margin-top:4px;"><span class="timing-label" style="font-weight:700; color:#93c5fd;">= Gesamtdauer</span><span class="timing-val" style="color:#93c5fd;">${totalMins} Min</span></div>`;
    html += `<div class="timing-row"><span class="timing-label">Ende der Fahrt</span><span class="timing-val">${endStr} Uhr</span></div>`;
    html += `</div>`;

    // Konflikt-ErklÃ¤rung je Typ
    const blockRide = conflict.ride;
    html += `<div class="analyse-box red">`;
    html += `<div style="color:#fca5a5; font-weight:700; margin-bottom:6px;">âš ï¸ KONFLIKT ERKANNT: ${conflictTypeLabel(conflict.type)}</div>`;

    if (conflict.type === 'exact') {
        const cTs = new Date(blockRide.pickupTimestamp||blockRide.pickupTime).getTime();
        const cDurTotal = totalDuration(blockRide.duration||blockRide.estimatedDuration||20, 0);
        const cEnd = fmtTime(cTs + cDurTotal * 60000);
        html += rideDetailHtml(blockRide, 'ğŸš¨ Blockierende Fahrt (gleiche Zeit)');
        html += `<div class="timing-row"><span class="timing-label">Blockierende Fahrt endet</span><span class="timing-val">${cEnd} Uhr</span></div>`;
        html += `<div style="color:#fca5a5; font-weight:700; margin-top:6px; font-size:13px;">âŒ UM ${timeStr} UHR IST BEREITS EINE FAHRT GEBUCHT!</div>`;

    } else if (conflict.type === 'during') {
        const pTs = new Date(prevRide.pickupTimestamp||prevRide.pickupTime).getTime();
        const pDurTotal = totalDuration(prevRide.duration||prevRide.estimatedDuration||20, 0);
        const pEnd = fmtTime(pTs + pDurTotal * 60000);
        html += rideDetailHtml(prevRide, 'ğŸš– Laufende Fahrt (Taxi ist unterwegs)');
        html += `<div class="timing-row"><span class="timing-label">Fahrt gebucht um</span><span class="timing-val">${fmtTime(pTs)} Uhr</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">Fahrt endet um</span><span class="timing-val">${pEnd} Uhr</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">GewÃ¼nschter Slot</span><span class="timing-val">${timeStr} Uhr</span></div>`;
        html += `<div style="color:#fca5a5; font-weight:700; margin-top:6px; font-size:12px;">â†’ Das Taxi ist um ${timeStr} Uhr noch unterwegs!</div>`;

    } else if (conflict.type === 'prev_gap') {
        const pTs = new Date(prevRide.pickupTimestamp||prevRide.pickupTime).getTime();
        const pDurTotal = totalDuration(prevRide.duration||prevRide.estimatedDuration||20, 0);
        const pEndTs = pTs + pDurTotal * 60000;
        const pEnd = fmtTime(pEndTs);
        const dh = conflict.deadhead || '?';
        const gap = Math.round((slotTs - pEndTs) / 60000);
        const needed = dh + params.buffer;
        html += rideDetailHtml(prevRide, 'ğŸš– Vorherige Fahrt (blockiert Ankunft)');
        html += `<div class="timing-row"><span class="timing-label">Vorh. Fahrt endet</span><span class="timing-val">${pEnd} Uhr</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">Leerfahrt zum Abholort</span><span class="timing-val">${dh} Min</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">+ Sicherheits-Puffer</span><span class="timing-val">${params.buffer} Min</span></div>`;
        html += `<div class="timing-row" style="border-top:1px solid #ef4444; margin-top:4px; padding-top:4px;"><span class="timing-label" style="color:#fca5a5; font-weight:700;">= BenÃ¶tigt</span><span class="timing-val" style="color:#fca5a5;">${needed} Min</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">VerfÃ¼gbare LÃ¼cke</span><span class="timing-val">${gap} Min</span></div>`;
        html += `<div style="color:#fca5a5; font-weight:700; margin-top:6px; font-size:13px;">âŒ Es fehlen ${Math.abs(conflict.reserveMin)} Min!</div>`;
        if (conflict.earliestTs) {
            html += `<div style="color:#6ee7b7; margin-top:4px; font-size:12px;">âœ… FrÃ¼hestens mÃ¶glich: <strong>${fmtTime(conflict.earliestTs)} Uhr</strong></div>`;
        }

    } else if (conflict.type === 'next_gap') {
        const nTs = new Date(nextRide.pickupTimestamp||nextRide.pickupTime).getTime();
        const dh2 = conflict.deadhead || '?';
        const needed2 = dh2 + params.buffer;
        html += rideDetailHtml(nextRide, 'ğŸš¨ NÃ¤chste Fahrt (wird Ã¼berschnitten)');
        html += `<div class="timing-row"><span class="timing-label">Neue Fahrt endet</span><span class="timing-val">${endStr} Uhr</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">Leerfahrt zum nÃ¤chsten</span><span class="timing-val">${dh2} Min</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">+ Sicherheits-Puffer</span><span class="timing-val">${params.buffer} Min</span></div>`;
        html += `<div class="timing-row" style="border-top:1px solid #ef4444; margin-top:4px; padding-top:4px;"><span class="timing-label" style="color:#fca5a5; font-weight:700;">= BenÃ¶tigt</span><span class="timing-val" style="color:#fca5a5;">${needed2} Min</span></div>`;
        html += `<div class="timing-row"><span class="timing-label">VerfÃ¼gbare Zeit</span><span class="timing-val">${conflict.timeUntilNext} Min</span></div>`;
        html += `<div style="color:#fca5a5; font-weight:700; margin-top:6px; font-size:13px;">âŒ Es fehlen ${Math.abs(conflict.reserveNext)} Min!</div>`;
    }
    html += `</div>`; // end red box

    // â”€â”€ 3. TIMELINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="analyse-box" style="border-color:#334155;">`;
    html += `<div style="color:#94a3b8; font-weight:700; margin-bottom:8px; font-size:12px;">ğŸ“… TAGES-TIMELINE</div>`;
    html += buildTimeline(conflict, slotDt, slotTs, totalMins, driveMins, pickup, dest, prevRide, nextRide, dayRides);
    html += `</div>`;

    // â”€â”€ 4. Alle Fahrten am Tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (dayRides.length > 0) {
        html += `<div class="analyse-box" style="border-color:#334155;">`;
        html += `<div style="color:#94a3b8; font-weight:700; margin-bottom:8px; font-size:12px;">ğŸ“‹ ALLE FAHRTEN AM TAG (${dayRides.length})</div>`;
        dayRides.forEach((r, idx) => {
            const rTs = new Date(r.pickupTimestamp||r.pickupTime).getTime();
            const rDurTotal = totalDuration(r.duration||r.estimatedDuration||20, 0);
            const rEnd = fmtTime(rTs + rDurTotal * 60000);
            const isConflictRide = conflict.ride && conflict.ride.firebaseId === r.firebaseId;
            const col = isConflictRide ? '#fca5a5' : '#94a3b8';
            html += `<div style="border-bottom:1px solid #1e293b; padding:4px 0; font-size:11px; color:${col};">`;
            html += `<span style="font-weight:700;">${fmtTime(rTs)}â€“${rEnd}</span>`;
            html += ` ${isConflictRide ? 'âš ï¸ ' : ''}${(r.pickup||'?').substring(0,25)} â†’ ${(r.destination||'?').substring(0,25)}`;
            html += ` <span style="color:#475569;">(${r.duration||'?'} Min | ${r.status})</span>`;
            html += `</div>`;
        });
        html += `</div>`;
    }

    html += `</div>`; // end analyse-section

    body.innerHTML = html;
}

function conflictTypeLabel(type) {
    return {
        exact:    'EXAKTE ZEITÃœBERSCHNEIDUNG',
        during:   'TAXI NOCH UNTERWEGS',
        prev_gap: 'ZU WENIG ZEIT NACH VORHERIGER FAHRT',
        next_gap: 'ZU WENIG ZEIT VOR NÃ„CHSTER FAHRT'
    }[type] || type.toUpperCase();
}

function rideDetailHtml(ride, label) {
    if (!ride) return '';
    const rTs = new Date(ride.pickupTimestamp||ride.pickupTime).getTime();
    const rDurTotal = totalDuration(ride.duration||ride.estimatedDuration||20, 0);
    const rEnd = fmtTime(rTs + rDurTotal * 60000);
    const name = ride.customerName || ride.name || ride.passengerName || 'â€“';
    let h = `<div style="background:#0f172a; border-radius:6px; padding:8px; margin-bottom:8px; border:1px solid #334155;">`;
    h += `<div style="color:#fde68a; font-weight:700; font-size:11px; margin-bottom:4px;">${label}</div>`;
    h += `<div class="timing-row"><span class="timing-label">Zeit</span><span class="timing-val">${fmtTime(rTs)}â€“${rEnd} Uhr</span></div>`;
    if (name !== 'â€“') h += `<div class="timing-row"><span class="timing-label">Kunde</span><span class="timing-val" style="font-size:11px;">${name}</span></div>`;
    h += `<div class="timing-row"><span class="timing-label">Von</span><span class="timing-val" style="font-size:11px; max-width:160px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${ride.pickup||'?'}</span></div>`;
    h += `<div class="timing-row"><span class="timing-label">Nach</span><span class="timing-val" style="font-size:11px; max-width:160px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${ride.destination||'?'}</span></div>`;
    h += `<div class="timing-row"><span class="timing-label">Fahrtdauer</span><span class="timing-val">${ride.duration||'?'} Min + ${params.boarding+params.alighting} Min</span></div>`;
    h += `</div>`;
    return h;
}

function buildTimeline(conflict, slotDt, slotTs, totalMins, driveMins, pickup, dest, prevRide, nextRide, dayRides) {
    // Sammle Events fÃ¼r die Timeline
    const events = [];

    dayRides.forEach((r, idx) => {
        const rTs = new Date(r.pickupTimestamp||r.pickupTime).getTime();
        const rDurTotal = totalDuration(r.duration||r.estimatedDuration||20, 0);
        const rEndTs = rTs + rDurTotal * 60000;
        const isConf = conflict.ride && conflict.ride.firebaseId === r.firebaseId;
        events.push({ ts: rTs, endTs: rEndTs, label: (r.pickup||'?').substring(0,20), type: isConf ? 'conflict' : 'existing', idx: idx+1 });
    });

    // Neue Fahrt
    events.push({ ts: slotTs, endTs: slotTs + totalMins * 60000, label: pickup.substring(0,20), type: 'newride' });

    // Sortiere nach Zeit
    events.sort((a, b) => a.ts - b.ts);

    let html = '<div class="timeline">';
    let prevEndTs = null;

    events.forEach(ev => {
        // LÃ¼cke / Leerfahrt zwischen Events
        if (prevEndTs && ev.ts > prevEndTs) {
            const gapMin = Math.round((ev.ts - prevEndTs) / 60000);
            if (gapMin > 0) {
                html += `<div class="tl-row" style="opacity:0.5;">`;
                html += `<span class="tl-time">${fmtTime(prevEndTs)}</span>`;
                html += `<div class="tl-bar"><span class="tl-block deadhead">â†— Leerfahrt / Pause ${gapMin} Min</span></div>`;
                html += `</div>`;
            }
        }

        const endStr2 = fmtTime(ev.endTs);
        const durMin = Math.round((ev.endTs - ev.ts) / 60000);
        const typeClass = ev.type;
        const icon = ev.type === 'newride' ? 'ğŸ†•' : (ev.type === 'conflict' ? 'âš ï¸' : `${ev.idx}.`);
        const extraStyle = ev.type === 'newride' ? ' font-style:italic;' : '';

        html += `<div class="tl-row">`;
        html += `<span class="tl-time" style="color:${ev.type==='conflict'?'#fca5a5':(ev.type==='newride'?'#93c5fd':'#64748b')};">${fmtTime(ev.ts)}</span>`;
        html += `<div class="tl-bar">`;
        html += `<span class="tl-block ${typeClass}" style="${extraStyle}">${icon} ${ev.label} (${durMin} Min)</span>`;
        html += `<span style="font-size:10px; color:#475569; margin-left:4px;">â†’ ${endStr2}</span>`;
        html += `</div>`;
        html += `</div>`;

        prevEndTs = ev.endTs;
    });

    html += '</div>';
    return html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAHRTKALENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function openKalender() {
    const card = document.getElementById('kalender-card');
    const content = document.getElementById('kalender-content');
    card.style.display = 'block';
    content.innerHTML = '<div style="color:#64748b; font-size:13px;"><span class="spinner"></span> Lade alle Fahrtenâ€¦</div>';

    if (!db) { showStatus('âš ï¸ Firebase nicht verbunden', 'err'); return; }

    try {
        const snap = await db.ref('rides').once('value');
        allRidesCache = snap.val() || {};

        const skipStatus = ['cancelled', 'storniert', 'completed', 'abgeschlossen'];
        const skipSource = ['hotel_calendar_import'];

        // Gruppiere nach Datum
        const byDate = {};
        Object.entries(allRidesCache).forEach(([id, r]) => {
            if (skipStatus.includes(r.status)) return;
            if (skipSource.includes(r.source)) return;
            const ts = r.pickupTimestamp || r.pickupTime;
            if (!ts) return;
            const d = new Date(ts);
            const dateStr = getLocalDateString(d);
            if (!byDate[dateStr]) byDate[dateStr] = [];
            byDate[dateStr].push({ ...r, firebaseId: id });
        });

        const dates = Object.keys(byDate).sort();
        document.getElementById('kalender-count').textContent = `${dates.length} Tage`;

        if (dates.length === 0) {
            content.innerHTML = '<div style="color:#64748b; font-size:13px;">Keine aktiven Fahrten gefunden.</div>';
            return;
        }

        // Gruppiere nach Monat
        const byMonth = {};
        dates.forEach(d => {
            const m = d.substring(0, 7); // YYYY-MM
            if (!byMonth[m]) byMonth[m] = [];
            byMonth[m].push(d);
        });

        const todayStr = getLocalDateString(new Date());
        let html = '';

        Object.entries(byMonth).forEach(([month, monthDates]) => {
            const [yr, mo] = month.split('-');
            const monthName = new Date(parseInt(yr), parseInt(mo) - 1, 1)
                .toLocaleDateString('de-DE', { month: 'long', year: 'numeric' });

            html += `<div class="kal-month">`;
            html += `<div class="kal-month-title">ğŸ“† ${monthName}</div>`;
            html += `<div class="kal-days">`;

            monthDates.forEach(dateStr => {
                const rides = byDate[dateStr].sort((a, b) =>
                    new Date(a.pickupTimestamp||a.pickupTime) - new Date(b.pickupTimestamp||b.pickupTime));
                const [yr2, mo2, da2] = dateStr.split('-').map(Number);
                const dateObj = new Date(yr2, mo2 - 1, da2);
                const wd = dateObj.toLocaleDateString('de-DE', { weekday: 'short' });
                const isToday = dateStr === todayStr;
                const cnt = rides.length;

                // Dots (max 5)
                const dots = rides.slice(0, 5).map(r => {
                    const cls = r.status === 'assigned' ? 'assigned' : (r.status === 'new' ? 'new' : '');
                    return `<span class="kal-dot ${cls}"></span>`;
                }).join('');

                html += `<div class="kal-day${isToday ? ' today' : ''}" onclick="selectKalenderDay('${dateStr}')">`;
                html += `<span class="kal-day-wd">${wd}</span>`;
                html += `<span class="kal-day-date">${da2}.</span>`;
                html += `<span class="kal-day-cnt">${cnt} Fahrt${cnt !== 1 ? 'en' : ''}</span>`;
                html += `<div class="kal-day-bar">${dots}</div>`;
                html += `</div>`;
            });

            html += `</div>`; // kal-days

            // Detail-Liste fÃ¼r jeden Tag im Monat
            monthDates.forEach(dateStr => {
                const rides = byDate[dateStr].sort((a, b) =>
                    new Date(a.pickupTimestamp||a.pickupTime) - new Date(b.pickupTimestamp||b.pickupTime));

                html += `<div id="kal-detail-${dateStr}" style="display:none; margin-top:8px;">`;
                html += `<div class="kal-day-list">`;
                rides.forEach(r => {
                    const rTs = new Date(r.pickupTimestamp||r.pickupTime);
                    const timeStr2 = rTs.toLocaleTimeString('de-DE', {hour:'2-digit',minute:'2-digit'});
                    const dur = r.duration || r.estimatedDuration || '?';
                    const name = r.customerName || r.name || r.passengerName || '';
                    const pickup = (r.pickup||'').substring(0, 30);
                    const dest   = (r.destination||'').substring(0, 30);
                    const statusBadge = r.status === 'assigned'
                        ? '<span class="badge badge-assigned" style="font-size:10px;">assigned</span>'
                        : `<span class="badge badge-other" style="font-size:10px;">${r.status}</span>`;

                    html += `<div class="kal-ride-row" onclick="fillFromRide('${dateStr}', '${timeStr2}', \`${r.pickup||''}\`, \`${r.destination||''}\`)">`;
                    html += `<span class="kal-ride-time">${timeStr2}</span>`;
                    html += `<div class="kal-ride-info">`;
                    if (name) html += `<div class="kal-ride-name">${name}</div>`;
                    html += `<div>${pickup} â†’ ${dest}</div>`;
                    html += `<div style="color:#475569;">${dur} Min ${statusBadge}</div>`;
                    html += `</div>`;
                    html += `<button class="kal-ride-btn" onclick="event.stopPropagation(); fillFromRide('${dateStr}', '${timeStr2}', \`${r.pickup||''}\`, \`${r.destination||''}\`)">â–¶ Testen</button>`;
                    html += `</div>`;
                });
                html += `</div></div>`; // kal-day-list + kal-detail
            });

            html += `</div>`; // kal-month
        });

        content.innerHTML = html;
        showStatus(`âœ… ${dates.length} Tage mit Fahrten geladen`, 'ok');

    } catch(e) {
        content.innerHTML = `<div style="color:#fca5a5;">âŒ Fehler: ${e.message}</div>`;
    }
}

let lastKalDetailOpen = null;

function selectKalenderDay(dateStr) {
    // Datum ins Formular Ã¼bernehmen
    document.getElementById('in-date').value = dateStr;

    // Detail-Liste ein-/ausklappen
    const detail = document.getElementById('kal-detail-' + dateStr);
    if (!detail) return;

    if (lastKalDetailOpen && lastKalDetailOpen !== dateStr) {
        const prev = document.getElementById('kal-detail-' + lastKalDetailOpen);
        if (prev) prev.style.display = 'none';
    }

    const isOpen = detail.style.display !== 'none';
    detail.style.display = isOpen ? 'none' : 'block';
    lastKalDetailOpen = isOpen ? null : dateStr;

    // Fahrten fÃ¼r diesen Tag laden
    if (!isOpen) loadRidesForDate();
}

function fillFromRide(dateStr, timeStr, pickup, dest) {
    document.getElementById('in-date').value = dateStr;
    document.getElementById('in-time').value = timeStr;
    if (pickup) document.getElementById('in-pickup').value = pickup;
    if (dest)   document.getElementById('in-dest').value   = dest;
    log(`ğŸ“‹ Fahrt Ã¼bernommen: ${dateStr} ${timeStr} | ${pickup} â†’ ${dest}`, 'info');
    // Scroll zum Formular
    document.getElementById('btn-check').scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HILFSFUNKTIONEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fillTime(timeStr) {
    document.getElementById('in-time').value = timeStr;
    runCheck();
}

function fillFromLog() {
    document.getElementById('in-date').value = '2026-03-02';
    document.getElementById('in-time').value = '06:15';
    document.getElementById('in-pickup').value = 'Amselring 10, Heringsdorf';
    document.getElementById('in-dest').value = 'LabahnstraÃŸe 18, Heringsdorf';
    log('ğŸ“‹ Log-Beispiel geladen: 02.03.2026 06:15', 'info');
}

function toggleSection(id) {
    const body = document.getElementById(id + '-body');
    const arrow = document.getElementById(id + '-arrow');
    const hidden = body.style.display === 'none';
    body.style.display = hidden ? '' : 'none';
    arrow.textContent = hidden ? 'â–¼' : 'â–¶';
}

// Datum auf heute vorbelegen
document.getElementById('in-date').value = getLocalDateString(new Date());
</script>
</body>
</html>
