<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konflikt-Tester â€“ Live</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0f172a; color: #e2e8f0; min-height: 100vh; padding: 16px; }

        h1 { color: #fbbf24; font-size: 20px; margin-bottom: 4px; }
        .subtitle { color: #64748b; font-size: 13px; margin-bottom: 20px; }

        .card { background: #1e293b; border-radius: 12px; padding: 16px; margin-bottom: 16px; border: 1px solid #334155; }
        .card h2 { font-size: 14px; font-weight: 600; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px; }

        .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }

        label { display: block; font-size: 12px; color: #94a3b8; margin-bottom: 4px; }
        input, select { width: 100%; padding: 8px 10px; background: #0f172a; border: 1px solid #334155; border-radius: 8px; color: #e2e8f0; font-size: 14px; }
        input:focus, select:focus { outline: none; border-color: #fbbf24; }

        .param-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .param-row label { width: 200px; font-size: 13px; color: #cbd5e1; margin: 0; flex-shrink: 0; }
        .param-row input[type=range] { flex: 1; accent-color: #fbbf24; }
        .param-value { width: 55px; text-align: right; font-weight: 600; color: #fbbf24; font-size: 14px; }

        button { padding: 10px 20px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.15s; }
        .btn-primary { background: #fbbf24; color: #0f172a; }
        .btn-primary:hover { background: #f59e0b; }
        .btn-primary:disabled { background: #475569; color: #94a3b8; cursor: not-allowed; }
        .btn-secondary { background: #334155; color: #e2e8f0; }
        .btn-secondary:hover { background: #475569; }

        #status { font-size: 13px; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; display: none; }
        .status-ok { background: #064e3b; color: #6ee7b7; border: 1px solid #10b981; }
        .status-err { background: #7f1d1d; color: #fca5a5; border: 1px solid #ef4444; }
        .status-info { background: #1e3a5f; color: #93c5fd; border: 1px solid #3b82f6; }

        /* Ergebnis */
        #result { display: none; }
        .result-frei { border-left: 4px solid #10b981; background: #042f2e; }
        .result-konflikt { border-left: 4px solid #ef4444; background: #2d0d0d; }
        .result-warnung { border-left: 4px solid #f59e0b; background: #2d1f00; }
        .result-title { font-size: 20px; font-weight: 700; margin-bottom: 10px; }
        .result-frei .result-title { color: #10b981; }
        .result-konflikt .result-title { color: #ef4444; }
        .result-warnung .result-title { color: #f59e0b; }

        .detail-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #1e293b; font-size: 13px; }
        .detail-row:last-child { border: none; }
        .detail-label { color: #94a3b8; }
        .detail-value { font-weight: 600; color: #e2e8f0; }

        .alt-btn { display: inline-block; margin: 4px 4px 0 0; padding: 6px 14px; border-radius: 20px; font-size: 13px; font-weight: 600; cursor: pointer; border: none; }
        .alt-before { background: #92400e; color: #fde68a; }
        .alt-after  { background: #064e3b; color: #6ee7b7; }

        /* Fahrten-Tabelle */
        .rides-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 8px; }
        .rides-table th { text-align: left; color: #64748b; padding: 4px 8px; border-bottom: 1px solid #334155; }
        .rides-table td { padding: 5px 8px; border-bottom: 1px solid #1e293b; }
        .rides-table tr:hover td { background: #1e293b; }
        .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .badge-assigned { background: #92400e; color: #fde68a; }
        .badge-new      { background: #1e3a5f; color: #93c5fd; }
        .badge-other    { background: #334155; color: #94a3b8; }

        .log-box { background: #020617; border-radius: 8px; padding: 12px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 11px; margin-top: 10px; }
        .log-ok   { color: #6ee7b7; }
        .log-err  { color: #fca5a5; }
        .log-warn { color: #fde68a; }
        .log-info { color: #93c5fd; }
        .log-dim  { color: #475569; }

        .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid #475569; border-top-color: #fbbf24; border-radius: 50%; animation: spin 0.6s linear infinite; vertical-align: middle; margin-right: 6px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .tag { display: inline-block; padding: 1px 6px; border-radius: 4px; font-size: 11px; background: #334155; color: #94a3b8; margin-left: 4px; }

        .section-toggle { cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; }
        .section-toggle:hover h2 { color: #e2e8f0; }

        /* Karte */
        #map-card { display: none; }
        #map { height: 420px; border-radius: 8px; margin-top: 10px; border: 1px solid #334155; }

        /* Legende */
        .map-legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
        .legend-line { width: 24px; height: 3px; flex-shrink: 0; border-radius: 2px; }

        /* Leaflet popup dark */
        .leaflet-popup-content-wrapper { background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; }
        .leaflet-popup-tip { background: #1e293b; }
        .leaflet-popup-content { font-size: 12px; line-height: 1.5; }
        .popup-title { font-weight: 700; color: #fbbf24; margin-bottom: 4px; }
        .popup-conflict { color: #fca5a5; font-weight: 600; }
        .popup-ok { color: #6ee7b7; font-weight: 600; }
    </style>
</head>
<body>

<h1>ğŸš• Konflikt-Tester <span class="tag">Live</span></h1>
<p class="subtitle">Echte Firebase-Daten Â· Einstellbare Parameter Â· Direktes Testen Â· Kartenansicht</p>

<div id="status"></div>

<!-- PARAMETER -->
<div class="card">
    <div class="section-toggle" onclick="toggleSection('params')">
        <h2>âš™ï¸ Parameter</h2>
        <span id="params-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="params-body">
        <div class="param-row">
            <label>Einsteige-Zeit (boardingTime)</label>
            <input type="range" id="p-boarding" min="0" max="10" step="1" value="3" oninput="updateParam('boarding', this.value)">
            <span class="param-value" id="v-boarding">3 Min</span>
        </div>
        <div class="param-row">
            <label>Aussteige-Zeit (alightingTime)</label>
            <input type="range" id="p-alighting" min="0" max="10" step="1" value="2" oninput="updateParam('alighting', this.value)">
            <span class="param-value" id="v-alighting">2 Min</span>
        </div>
        <div class="param-row">
            <label>Sicherheits-Puffer (bufferTime)</label>
            <input type="range" id="p-buffer" min="0" max="20" step="1" value="5" oninput="updateParam('buffer', this.value)">
            <span class="param-value" id="v-buffer">5 Min</span>
        </div>
        <div class="param-row">
            <label>Waypoint-Stopzeit</label>
            <input type="range" id="p-waypoint" min="0" max="15" step="1" value="5" oninput="updateParam('waypoint', this.value)">
            <span class="param-value" id="v-waypoint">5 Min</span>
        </div>
        <div class="param-row">
            <label>Mindest-Abstand zwischen Fahrten</label>
            <input type="range" id="p-mindest" min="0" max="30" step="5" value="0" oninput="updateParam('mindest', this.value)">
            <span class="param-value" id="v-mindest">0 Min</span>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; font-size:12px; color:#64748b;">
            <button class="btn-secondary" style="padding:5px 12px; font-size:12px;" onclick="resetParams()">â†º ZurÃ¼cksetzen</button>
            <span>Standard-Werte: Einsteigen 3, Aussteigen 2, Puffer 5, Waypoint 5, Mindest 0</span>
        </div>
    </div>
</div>

<!-- EINGABE -->
<div class="card">
    <h2>ğŸ” Termin prÃ¼fen</h2>
    <div class="grid2" style="margin-bottom:10px;">
        <div>
            <label>Datum</label>
            <input type="date" id="in-date">
        </div>
        <div>
            <label>Uhrzeit</label>
            <input type="time" id="in-time" value="08:00">
        </div>
    </div>
    <div style="margin-bottom:10px;">
        <label>Abholadresse</label>
        <input type="text" id="in-pickup" placeholder="z.B. Amselring 10, Heringsdorf" value="Amselring 10, Heringsdorf">
    </div>
    <div style="margin-bottom:10px;">
        <label>Zieladresse</label>
        <input type="text" id="in-dest" placeholder="z.B. LabahnstraÃŸe 18, Heringsdorf" value="LabahnstraÃŸe 18, Heringsdorf">
    </div>
    <div class="grid2" style="margin-bottom:14px;">
        <div>
            <label>Passagiere</label>
            <select id="in-pax">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>
        </div>
        <div>
            <label>Zwischenstopps</label>
            <select id="in-waypoints">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
            </select>
        </div>
    </div>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn-primary" id="btn-check" onclick="runCheck()">â–¶ Konflikt prÃ¼fen</button>
        <button class="btn-secondary" onclick="loadRidesForDate()">ğŸ“… Fahrten laden</button>
        <button class="btn-secondary" onclick="fillFromLog()">ğŸ“‹ Beispiel: Log 02.03</button>
    </div>
</div>

<!-- ERGEBNIS -->
<div class="card" id="result">
    <h2>ğŸ“Š Ergebnis</h2>
    <div id="result-body"></div>
    <div id="log-output" class="log-box" style="display:none;"></div>
    <button class="btn-secondary" style="margin-top:8px; font-size:12px; padding:4px 10px;" onclick="toggleLog()">ğŸ” Debug-Log</button>
</div>

<!-- KARTE -->
<div class="card" id="map-card">
    <div class="section-toggle" onclick="toggleSection('map')">
        <h2>ğŸ—ºï¸ Kartenansicht</h2>
        <span id="map-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="map-body">
        <div id="map"></div>
        <div class="map-legend">
            <div class="legend-item">
                <div class="legend-line" style="background:#3b82f6;"></div>
                <span>Neue Fahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#94a3b8;"></div>
                <span>Bestehende Fahrten</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#ef4444;"></div>
                <span>Konflikt-Fahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background:#f59e0b; border-top: 2px dashed #f59e0b; height:0;"></div>
                <span>Leerfahrt</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#3b82f6;"></div>
                <span>Abholung (neu)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#10b981;"></div>
                <span>Ziel (neu)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#fbbf24;"></div>
                <span>Bestehende Stops</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background:#ef4444;"></div>
                <span>Konflikt-Stop</span>
            </div>
        </div>
    </div>
</div>

<!-- FAHRTEN AM TAG -->
<div class="card" id="rides-card" style="display:none;">
    <div class="section-toggle" onclick="toggleSection('rides')">
        <h2>ğŸ“… Fahrten am gewÃ¤hlten Tag <span id="rides-date-label" class="tag"></span></h2>
        <span id="rides-arrow" style="color:#64748b;">â–¼</span>
    </div>
    <div id="rides-body">
        <table class="rides-table" id="rides-table">
            <thead><tr><th>Zeit</th><th>Von</th><th>Nach</th><th>Dauer</th><th>Status</th></tr></thead>
            <tbody id="rides-tbody"></tbody>
        </table>
    </div>
</div>

<!-- Firebase + Leaflet + Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIREBASE INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const FIREBASE_CONFIG = {
    apiKey: "AIzaSyD2eHFuplImxBCijd3MWlKyCwXUZHLmhhE",
    authDomain: "taxi-heringsdorf.firebaseapp.com",
    databaseURL: "https://taxi-heringsdorf-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "taxi-heringsdorf",
    storageBucket: "taxi-heringsdorf.firebasestorage.app"
};

let db = null;
let allRidesCache = {};
let logLines = [];

function showStatus(msg, type = 'info') {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = 'status-' + type;
    el.style.display = 'block';
}

async function initFirebase() {
    try {
        firebase.initializeApp(FIREBASE_CONFIG);
        db = firebase.database();
        showStatus('âœ… Firebase verbunden â€“ ' + FIREBASE_CONFIG.databaseURL, 'ok');
        log('âœ… Firebase bereit', 'ok');
    } catch(e) {
        showStatus('âŒ Firebase-Fehler: ' + e.message, 'err');
    }
}

initFirebase();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARAMETER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let params = { boarding: 3, alighting: 2, buffer: 5, waypoint: 5, mindest: 0 };

function updateParam(key, val) {
    params[key] = parseInt(val);
    document.getElementById('v-' + key).textContent = val + ' Min';
}

function resetParams() {
    const defaults = { boarding: 3, alighting: 2, buffer: 5, waypoint: 5, mindest: 0 };
    for (const [k, v] of Object.entries(defaults)) {
        params[k] = v;
        document.getElementById('p-' + k).value = v;
        document.getElementById('v-' + k).textContent = v + ' Min';
    }
    log('â†º Parameter auf Standard zurÃ¼ckgesetzt', 'info');
}

function totalDuration(driveMins, waypointCount = 0) {
    return driveMins + params.boarding + params.alighting + (waypointCount * params.waypoint);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOCODING (Nominatim)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const geocodeCache = {};

async function geocode(address) {
    if (geocodeCache[address]) return geocodeCache[address];
    try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', Usedom, Deutschland')}&limit=1&addressdetails=0`;
        const resp = await fetch(url, { headers: { 'Accept-Language': 'de' } });
        const data = await resp.json();
        if (data && data[0]) {
            const coords = { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
            geocodeCache[address] = coords;
            return coords;
        }
        // Fallback: ohne Usedom
        const url2 = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
        const resp2 = await fetch(url2);
        const data2 = await resp2.json();
        if (data2 && data2[0]) {
            const coords = { lat: parseFloat(data2[0].lat), lon: parseFloat(data2[0].lon) };
            geocodeCache[address] = coords;
            return coords;
        }
    } catch(e) {}
    return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTE (OSRM) â€“ mit Geometrie fÃ¼r Karte
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function calcRoute(from, to) {
    if (!from || !to) return { duration: 10, distance: 0, geometry: null };
    try {
        const url = `https://router.project-osrm.org/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=full&geometries=geojson`;
        const resp = await fetch(url);
        const data = await resp.json();
        if (data.routes && data.routes[0]) {
            return {
                duration: Math.ceil(data.routes[0].duration / 60),
                distance: +(data.routes[0].distance / 1000).toFixed(1),
                geometry: data.routes[0].geometry
            };
        }
    } catch(e) {}
    return { duration: 10, distance: 0, geometry: null };
}

// GeoJSON Koordinaten [lon,lat] â†’ Leaflet [lat,lon]
function geomToLatLngs(geometry) {
    if (!geometry || !geometry.coordinates) return [];
    return geometry.coordinates.map(c => [c[1], c[0]]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KARTE (Leaflet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let map = null;
let mapLayers = [];

function initMap() {
    if (map) return;
    map = L.map('map', { zoomControl: true }).setView([53.96, 14.07], 12);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OSM</a> Â© <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }).addTo(map);
}

function clearMapLayers() {
    mapLayers.forEach(l => map.removeLayer(l));
    mapLayers = [];
}

function addMapLayer(layer) {
    layer.addTo(map);
    mapLayers.push(layer);
}

function makeIcon(color, label = '') {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="36" viewBox="0 0 28 36">
        <path d="M14 0C6.27 0 0 6.27 0 14c0 9.33 14 22 14 22S28 23.33 28 14C28 6.27 21.73 0 14 0z" fill="${color}" stroke="#0f172a" stroke-width="2"/>
        <text x="14" y="18" text-anchor="middle" fill="white" font-size="9" font-weight="bold" font-family="sans-serif">${label}</text>
    </svg>`;
    return L.divIcon({
        html: svg,
        className: '',
        iconSize: [28, 36],
        iconAnchor: [14, 36],
        popupAnchor: [0, -36]
    });
}

async function renderMapAfterCheck(conflict, slotDateTime, pickupAddr, destAddr,
    pickupCoords, destCoords, newRouteGeom,
    prevRide, nextRide, dayRides,
    prevDestCoords, nextPickupCoords,
    deadheadPrevGeom, deadheadNextGeom) {

    document.getElementById('map-card').style.display = 'block';
    initMap();
    clearMapLayers();

    const bounds = [];
    let rideIndex = 0;

    // â”€â”€ Alle anderen Fahrten am Tag (grau) â”€â”€
    for (const r of dayRides) {
        rideIndex++;
        const isConflict = conflict && conflict.ride && conflict.ride.firebaseId === r.firebaseId;
        const isPrev = prevRide && prevRide.firebaseId === r.firebaseId;
        const isNext = nextRide && nextRide.firebaseId === r.firebaseId;

        const rPickupAddr = r.pickup || '';
        const rDestAddr   = r.destination || '';
        const rTs = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = rTs.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

        // Koordinaten aus Cache oder Geocoding
        let rFrom = r.pickupLat ? { lat: r.pickupLat, lon: r.pickupLon } : (r.pickupCoords || null);
        let rTo   = r.destLat   ? { lat: r.destLat,   lon: r.destLon   } : (r.destCoords   || null);
        if (!rFrom) rFrom = geocodeCache[rPickupAddr] || null;
        if (!rTo)   rTo   = geocodeCache[rDestAddr]   || null;

        const color = isConflict ? '#ef4444' : '#94a3b8';
        const iconColor = isConflict ? '#ef4444' : '#fbbf24';
        const weight = isConflict ? 4 : 2;
        const opacity = isConflict ? 0.9 : 0.5;

        const label = isConflict ? '!' : String(rideIndex);
        const roleStr = isConflict ? ' âš ï¸ KONFLIKT' : (isPrev ? ' (vorher)' : (isNext ? ' (nÃ¤chste)' : ''));

        const popupContent = `
            <div class="popup-title">${timeStr} Uhr${roleStr}</div>
            <div>${rPickupAddr}</div>
            <div style="color:#64748b;">â†“</div>
            <div>${rDestAddr}</div>
            <div style="margin-top:4px; color:#94a3b8;">${r.duration || r.estimatedDuration || '?'} Min | ${r.status}</div>
            ${isConflict ? `<div class="popup-conflict" style="margin-top:4px;">${conflict.msg}</div>` : ''}
        `;

        if (rFrom) {
            const m = L.marker([rFrom.lat, rFrom.lon], { icon: makeIcon(iconColor, label) })
                .bindPopup(popupContent);
            addMapLayer(m);
            bounds.push([rFrom.lat, rFrom.lon]);
        }
        if (rTo) {
            const mTo = L.marker([rTo.lat, rTo.lon], { icon: makeIcon(isConflict ? '#ef4444' : '#475569', 'â—') })
                .bindPopup(popupContent);
            addMapLayer(mTo);
            bounds.push([rTo.lat, rTo.lon]);
        }

        // Route der bestehenden Fahrt (falls Koordinaten bekannt)
        if (rFrom && rTo) {
            try {
                const rt = await calcRoute(rFrom, rTo);
                if (rt.geometry) {
                    const pl = L.polyline(geomToLatLngs(rt.geometry), {
                        color, weight, opacity
                    }).bindPopup(popupContent);
                    addMapLayer(pl);
                }
            } catch(e) {}
        }
    }

    // â”€â”€ Leerfahrt VOR neuer Fahrt (orange gestrichelt) â”€â”€
    if (deadheadPrevGeom) {
        const pl = L.polyline(geomToLatLngs(deadheadPrevGeom), {
            color: '#f59e0b', weight: 2, opacity: 0.8,
            dashArray: '6 6'
        }).bindPopup('<div class="popup-title" style="color:#f59e0b;">Leerfahrt (vorher)</div>');
        addMapLayer(pl);
    }

    // â”€â”€ Leerfahrt NACH neuer Fahrt (orange gestrichelt) â”€â”€
    if (deadheadNextGeom) {
        const pl = L.polyline(geomToLatLngs(deadheadNextGeom), {
            color: '#f59e0b', weight: 2, opacity: 0.8,
            dashArray: '6 6'
        }).bindPopup('<div class="popup-title" style="color:#f59e0b;">Leerfahrt (danach)</div>');
        addMapLayer(pl);
    }

    // â”€â”€ Neue Fahrt (blau, dick) â”€â”€
    const newEndTs = slotDateTime.getTime() + totalDuration(0, 0) * 60000;
    const newTimeStr = slotDateTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    const newPopup = `
        <div class="popup-title" style="color:#3b82f6;">ğŸ†• Neue Fahrt â€“ ${newTimeStr} Uhr</div>
        <div>${pickupAddr}</div>
        <div style="color:#64748b;">â†“</div>
        <div>${destAddr}</div>
        ${conflict ? `<div class="popup-conflict" style="margin-top:4px;">âŒ ${conflict.msg}</div>` :
                     `<div class="popup-ok" style="margin-top:4px;">âœ… Slot frei</div>`}
    `;

    if (newRouteGeom) {
        const pl = L.polyline(geomToLatLngs(newRouteGeom), {
            color: '#3b82f6', weight: 5, opacity: 0.9
        }).bindPopup(newPopup);
        addMapLayer(pl);
    }

    if (pickupCoords) {
        const m = L.marker([pickupCoords.lat, pickupCoords.lon], { icon: makeIcon('#3b82f6', 'A') })
            .bindPopup(`<div class="popup-title" style="color:#3b82f6;">Abholung (neu)</div><div>${pickupAddr}</div>`);
        addMapLayer(m);
        bounds.push([pickupCoords.lat, pickupCoords.lon]);
    }

    if (destCoords) {
        const m = L.marker([destCoords.lat, destCoords.lon], { icon: makeIcon('#10b981', 'Z') })
            .bindPopup(`<div class="popup-title" style="color:#10b981;">Ziel (neu)</div><div>${destAddr}</div>`);
        addMapLayer(m);
        bounds.push([destCoords.lat, destCoords.lon]);
    }

    // Karte auf alle Punkte zoomen
    if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [30, 30] });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function log(msg, type = 'dim') {
    logLines.push({ msg, type });
    const box = document.getElementById('log-output');
    if (box.style.display !== 'none') renderLog();
}

function renderLog() {
    const box = document.getElementById('log-output');
    box.innerHTML = logLines.map(l =>
        `<div class="log-${l.type}">${l.msg}</div>`
    ).join('');
    box.scrollTop = box.scrollHeight;
}

let logVisible = false;
function toggleLog() {
    logVisible = !logVisible;
    const box = document.getElementById('log-output');
    box.style.display = logVisible ? 'block' : 'none';
    if (logVisible) renderLog();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAHRTEN LADEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getLocalDateString(date) {
    return date.getFullYear() + '-' +
        String(date.getMonth() + 1).padStart(2, '0') + '-' +
        String(date.getDate()).padStart(2, '0');
}

async function loadRidesForDate() {
    const dateStr = document.getElementById('in-date').value;
    if (!dateStr) { showStatus('âš ï¸ Bitte Datum wÃ¤hlen', 'err'); return; }
    if (!db) { showStatus('âš ï¸ Firebase nicht verbunden', 'err'); return; }

    showStatus('â³ Lade Fahrten...', 'info');
    log(`ğŸ“… Lade Fahrten fÃ¼r ${dateStr}...`, 'info');

    try {
        const snap = await db.ref('rides').once('value');
        allRidesCache = snap.val() || {};

        const skipStatus = ['cancelled', 'storniert', 'completed', 'abgeschlossen'];
        const skipSource = ['hotel_calendar_import'];

        const ridesOnDay = Object.entries(allRidesCache)
            .filter(([id, r]) => {
                if (skipStatus.includes(r.status)) return false;
                if (skipSource.includes(r.source)) return false;
                const ts = r.pickupTimestamp || r.pickupTime;
                if (!ts) return false;
                const d = new Date(ts);
                return getLocalDateString(d) === dateStr;
            })
            .map(([id, r]) => ({ ...r, firebaseId: id }))
            .sort((a, b) => {
                const ta = new Date(a.pickupTimestamp || a.pickupTime).getTime();
                const tb = new Date(b.pickupTimestamp || b.pickupTime).getTime();
                return ta - tb;
            });

        renderRidesTable(ridesOnDay, dateStr);
        showStatus(`âœ… ${ridesOnDay.length} Fahrt(en) am ${dateStr} geladen (${Object.keys(allRidesCache).length} gesamt)`, 'ok');
        log(`âœ… ${ridesOnDay.length} Fahrt(en) am ${dateStr}`, 'ok');

        // Karte nur mit Tagesfahrten anzeigen
        await renderMapDayOnly(ridesOnDay);
    } catch(e) {
        showStatus('âŒ Fehler: ' + e.message, 'err');
        log('âŒ ' + e.message, 'err');
    }
}

async function renderMapDayOnly(rides) {
    document.getElementById('map-card').style.display = 'block';
    initMap();
    clearMapLayers();
    const bounds = [];

    for (let i = 0; i < rides.length; i++) {
        const r = rides[i];
        const rTs = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = rTs.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

        let rFrom = r.pickupLat ? { lat: r.pickupLat, lon: r.pickupLon } : null;
        let rTo   = r.destLat   ? { lat: r.destLat,   lon: r.destLon   } : null;
        if (!rFrom && r.pickup)      rFrom = await geocode(r.pickup);
        if (!rTo   && r.destination) rTo   = await geocode(r.destination);

        const popupContent = `
            <div class="popup-title">${timeStr} Uhr â€“ Fahrt ${i+1}</div>
            <div>${r.pickup || '?'}</div>
            <div style="color:#64748b;">â†“</div>
            <div>${r.destination || '?'}</div>
            <div style="margin-top:4px; color:#94a3b8;">${r.duration || '?'} Min | ${r.status}</div>
        `;

        if (rFrom) {
            addMapLayer(L.marker([rFrom.lat, rFrom.lon], { icon: makeIcon('#fbbf24', String(i+1)) }).bindPopup(popupContent));
            bounds.push([rFrom.lat, rFrom.lon]);
        }
        if (rTo) {
            addMapLayer(L.marker([rTo.lat, rTo.lon], { icon: makeIcon('#475569', 'â—') }).bindPopup(popupContent));
            bounds.push([rTo.lat, rTo.lon]);
        }
        if (rFrom && rTo) {
            const rt = await calcRoute(rFrom, rTo);
            if (rt.geometry) {
                addMapLayer(L.polyline(geomToLatLngs(rt.geometry), {
                    color: '#94a3b8', weight: 2, opacity: 0.6
                }).bindPopup(popupContent));
            }
        }
    }

    if (bounds.length > 0) map.fitBounds(bounds, { padding: [30, 30] });
}

function renderRidesTable(rides, dateStr) {
    document.getElementById('rides-card').style.display = 'block';
    document.getElementById('rides-date-label').textContent = dateStr;

    const tbody = document.getElementById('rides-tbody');
    if (rides.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="color:#64748b; padding:12px;">Keine aktiven Fahrten an diesem Tag</td></tr>';
        return;
    }
    tbody.innerHTML = rides.map(r => {
        const t = new Date(r.pickupTimestamp || r.pickupTime);
        const timeStr = t.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
        const dur = r.duration || r.estimatedDuration || '?';
        const statusClass = r.status === 'assigned' ? 'assigned' : (r.status === 'new' ? 'new' : 'other');
        const pickup = (r.pickup || '').substring(0, 25) + ((r.pickup || '').length > 25 ? 'â€¦' : '');
        const dest   = (r.destination || '').substring(0, 25) + ((r.destination || '').length > 25 ? 'â€¦' : '');
        return `<tr>
            <td style="font-weight:600; color:#fbbf24;">${timeStr}</td>
            <td>${pickup}</td>
            <td>${dest}</td>
            <td>${dur} Min</td>
            <td><span class="badge badge-${statusClass}">${r.status}</span></td>
        </tr>`;
    }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KONFLIKT-PRÃœFUNG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function runCheck() {
    const dateStr = document.getElementById('in-date').value;
    const timeStr = document.getElementById('in-time').value;
    const pickupAddr = document.getElementById('in-pickup').value.trim();
    const destAddr   = document.getElementById('in-dest').value.trim();
    const waypointCount = parseInt(document.getElementById('in-waypoints').value);

    if (!dateStr || !timeStr || !pickupAddr || !destAddr) {
        showStatus('âš ï¸ Bitte alle Felder ausfÃ¼llen', 'err'); return;
    }
    if (!db) { showStatus('âš ï¸ Firebase nicht verbunden', 'err'); return; }

    const btn = document.getElementById('btn-check');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>PrÃ¼feâ€¦';
    logLines = [];
    document.getElementById('result').style.display = 'none';
    showStatus('â³ Koordinaten & Routen werden berechnetâ€¦', 'info');

    const slotDateTime = new Date(`${dateStr}T${timeStr}:00`);
    log(`ğŸ” PrÃ¼fe: ${slotDateTime.toLocaleString('de-DE')}`, 'info');
    log(`ğŸ“ ${pickupAddr} â†’ ${destAddr}`, 'info');
    log(`âš™ï¸ boarding=${params.boarding} alighting=${params.alighting} buffer=${params.buffer} waypoints=${waypointCount}Ã—${params.waypoint} mindest=${params.mindest}`, 'dim');

    // FÃ¼r Karte merken
    let deadheadPrevGeom = null;
    let deadheadNextGeom = null;
    let prevDestCoordsForMap = null;
    let nextPickupCoordsForMap = null;

    try {
        // 1. Firebase laden falls noch nicht
        if (Object.keys(allRidesCache).length === 0) {
            log('ğŸ“¡ Lade Firebaseâ€¦', 'info');
            const snap = await db.ref('rides').once('value');
            allRidesCache = snap.val() || {};
            log(`âœ… ${Object.keys(allRidesCache).length} Fahrten geladen`, 'ok');
        }

        // 2. Relevante Fahrten filtern (gleicher Tag, aktiv)
        const skipStatus = ['cancelled', 'storniert', 'completed', 'abgeschlossen'];
        const slotDateStr = getLocalDateString(slotDateTime);
        const slotTs = slotDateTime.getTime();

        const dayRides = Object.entries(allRidesCache)
            .filter(([id, r]) => {
                if (skipStatus.includes(r.status)) return false;
                if (r.source === 'hotel_calendar_import' || r.hotelCalendarId) return false;
                const ts = r.pickupTimestamp || r.pickupTime;
                if (!ts) return false;
                return getLocalDateString(new Date(ts)) === slotDateStr;
            })
            .map(([id, r]) => ({ ...r, firebaseId: id }))
            .sort((a, b) => new Date(a.pickupTimestamp||a.pickupTime) - new Date(b.pickupTimestamp||b.pickupTime));

        log(`ğŸ“… ${dayRides.length} aktive Fahrt(en) am ${slotDateStr}`, 'info');
        dayRides.forEach(r => {
            const t = new Date(r.pickupTimestamp || r.pickupTime);
            log(`   ${t.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} | ${r.pickup||'?'} â†’ ${r.destination||'?'} | ${r.duration||'?'} Min | ${r.status}`, 'dim');
        });

        // 3. Geocoding
        log('ğŸŒ Geocodiere Adressenâ€¦', 'info');
        const [pickupCoords, destCoords] = await Promise.all([geocode(pickupAddr), geocode(destAddr)]);
        if (!pickupCoords) { showStatus('âŒ Abholadresse nicht gefunden', 'err'); btn.disabled=false; btn.textContent='â–¶ Konflikt prÃ¼fen'; return; }
        if (!destCoords)   { showStatus('âŒ Zieladresse nicht gefunden',  'err'); btn.disabled=false; btn.textContent='â–¶ Konflikt prÃ¼fen'; return; }
        log(`âœ… Pickup: ${pickupCoords.lat.toFixed(4)}, ${pickupCoords.lon.toFixed(4)}`, 'ok');
        log(`âœ… Dest:   ${destCoords.lat.toFixed(4)}, ${destCoords.lon.toFixed(4)}`, 'ok');

        // 4. Neue Fahrt-Dauer berechnen
        log('ğŸ—ºï¸ Berechne Route der neuen Fahrt (OSRM)â€¦', 'info');
        const newRoute = await calcRoute(pickupCoords, destCoords);
        const newDriveMins = newRoute.duration;
        const newTotalMins = totalDuration(newDriveMins, waypointCount);
        const newEndTs = slotTs + newTotalMins * 60000;
        log(`ğŸš— Fahrtdauer: ${newDriveMins} Min | Gesamt: ${newTotalMins} Min (Ende: ${new Date(newEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})})`, 'ok');

        // 5. Vorherige Fahrt finden
        let prevRide = null;
        for (let i = dayRides.length - 1; i >= 0; i--) {
            const r = dayRides[i];
            const rTs = new Date(r.pickupTimestamp || r.pickupTime).getTime();
            if (rTs < slotTs) { prevRide = r; break; }
        }

        // 6. NÃ¤chste Fahrt finden
        let nextRide = null;
        for (const r of dayRides) {
            const rTs = new Date(r.pickupTimestamp || r.pickupTime).getTime();
            if (rTs > slotTs) { nextRide = r; break; }
        }

        // 7. Exakte Ãœberschneidung
        const exactOverlap = dayRides.find(r => new Date(r.pickupTimestamp || r.pickupTime).getTime() === slotTs);

        // â”€â”€ PRÃœFUNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let conflict = null;

        // A) Exakte ZeitÃ¼berschneidung
        if (exactOverlap) {
            conflict = { type: 'exact', ride: exactOverlap, msg: 'Exakt gleiche Uhrzeit bereits gebucht' };
            log('ğŸš¨ EXAKTE ZEITÃœBERSCHNEIDUNG!', 'err');
        }

        // B) Neuer Slot liegt wÃ¤hrend vorheriger Fahrt
        if (!conflict && prevRide) {
            const prevTs = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).getTime();
            const prevDur = totalDuration(prevRide.duration || prevRide.estimatedDuration || 20, 0);
            const prevEndTs = prevTs + prevDur * 60000;
            if (slotTs < prevEndTs) {
                conflict = { type: 'during', ride: prevRide, rideEnd: prevEndTs, msg: 'Taxi ist noch unterwegs' };
                log(`ğŸš¨ WÃ„HREND LAUFENDER FAHRT: ${new Date(prevTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} â€“ ${new Date(prevEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'err');
            }
        }

        // C) Zu wenig Zeit nach vorheriger Fahrt (Leerfahrt)
        if (!conflict && prevRide) {
            const prevTs = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).getTime();
            const prevDur = totalDuration(prevRide.duration || prevRide.estimatedDuration || 20, 0);
            const prevEndTs = prevTs + prevDur * 60000;
            if (slotTs >= prevEndTs) {
                log(`ğŸ—ºï¸ Leerfahrt: ${prevRide.destination||'?'} â†’ ${pickupAddr}`, 'info');
                let prevDestCoords = null;
                if (prevRide.destLat && prevRide.destLon) prevDestCoords = { lat: prevRide.destLat, lon: prevRide.destLon };
                else if (prevRide.destCoords) prevDestCoords = prevRide.destCoords;
                else prevDestCoords = await geocode(prevRide.destination);
                prevDestCoordsForMap = prevDestCoords;

                const deadhead = prevDestCoords ? await calcRoute(prevDestCoords, pickupCoords) : { duration: params.buffer + 5, geometry: null };
                deadheadPrevGeom = deadhead.geometry;
                const minGap = Math.max(deadhead.duration + params.buffer, params.mindest);
                const earliestTs = prevEndTs + minGap * 60000;
                const gapMin = Math.round((slotTs - prevEndTs) / 60000);
                const reserveMin = Math.round((slotTs - earliestTs) / 60000);

                log(`   Vorh. Fahrt endet: ${new Date(prevEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'dim');
                log(`   Leerfahrt: ${deadhead.duration} Min + Puffer: ${params.buffer} Min = ${minGap} Min benÃ¶tigt`, 'dim');
                log(`   LÃ¼cke: ${gapMin} Min | Reserve: ${reserveMin} Min`, reserveMin < 0 ? 'err' : (reserveMin === 0 ? 'warn' : 'ok'));

                if (slotTs < earliestTs) {
                    conflict = { type: 'prev_gap', ride: prevRide, deadhead: deadhead.duration, earliestTs, reserveMin,
                        msg: `Zu wenig Zeit nach vorheriger Fahrt (${Math.abs(reserveMin)} Min fehlen)` };
                    log('ğŸš¨ ZU WENIG ZEIT NACH VORHERIGER FAHRT', 'err');
                }
            }
        }

        // D) Neue Fahrt endet zu spÃ¤t fÃ¼r nÃ¤chste Fahrt
        if (!conflict && nextRide) {
            const nextTs = new Date(nextRide.pickupTimestamp || nextRide.pickupTime).getTime();
            log(`ğŸ—ºï¸ Leerfahrt zur nÃ¤chsten: ${destAddr} â†’ ${nextRide.pickup||'?'}`, 'info');
            let nextPickupCoords = null;
            if (nextRide.pickupLat && nextRide.pickupLon) nextPickupCoords = { lat: nextRide.pickupLat, lon: nextRide.pickupLon };
            else if (nextRide.pickupCoords) nextPickupCoords = nextRide.pickupCoords;
            else nextPickupCoords = await geocode(nextRide.pickup);
            nextPickupCoordsForMap = nextPickupCoords;

            const deadhead2 = nextPickupCoords ? await calcRoute(destCoords, nextPickupCoords) : { duration: params.buffer + 5, geometry: null };
            deadheadNextGeom = deadhead2.geometry;
            const neededGap = Math.max(deadhead2.duration + params.buffer, params.mindest);
            const earliestForNext = newEndTs + neededGap * 60000;
            const timeUntilNext = Math.round((nextTs - newEndTs) / 60000);
            const reserveNext = Math.round((nextTs - earliestForNext) / 60000);

            log(`   Neue Fahrt endet: ${new Date(newEndTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})}`, 'dim');
            log(`   Leerfahrt: ${deadhead2.duration} Min + Puffer: ${params.buffer} Min = ${neededGap} Min benÃ¶tigt`, 'dim');
            log(`   NÃ¤chste Fahrt: ${new Date(nextTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} | Reserve: ${reserveNext} Min`, reserveNext <= 0 ? (reserveNext < 0 ? 'err' : 'warn') : 'ok');

            if (earliestForNext >= nextTs) {
                const latestStartMs = nextTs - (newTotalMins + deadhead2.duration + params.buffer) * 60000;
                const latestRounded = (Math.floor(latestStartMs / (5 * 60000)) - 1) * (5 * 60000);
                const beforeAlt = latestRounded > 0 ? new Date(latestRounded) : null;
                conflict = { type: 'next_gap', ride: nextRide, deadhead: deadhead2.duration, neededGap, timeUntilNext, reserveNext, beforeAlt,
                    msg: `Taxi kommt nicht rechtzeitig zur nÃ¤chsten Fahrt (${Math.abs(reserveNext)} Min zu wenig)` };
                log('ğŸš¨ ZU WENIG ZEIT VOR NÃ„CHSTER FAHRT', 'err');
                if (beforeAlt) log(`   VORHER-Alternative: ${beforeAlt.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'})} Uhr`, 'warn');
            } else {
                log(`âœ… NÃ¤chste Fahrt: ${reserveNext} Min Reserve`, 'ok');
            }
        }

        // 8. Ergebnis anzeigen
        showResult(conflict, slotDateTime, pickupAddr, destAddr, newDriveMins, newTotalMins, prevRide, nextRide, dayRides);
        renderRidesTable(dayRides, slotDateStr);
        showStatus(conflict ? `âŒ KONFLIKT: ${conflict.msg}` : 'âœ… SLOT FREI', conflict ? 'err' : 'ok');

        // 9. Karte rendern
        await renderMapAfterCheck(
            conflict, slotDateTime, pickupAddr, destAddr,
            pickupCoords, destCoords, newRoute.geometry,
            prevRide, nextRide, dayRides,
            prevDestCoordsForMap, nextPickupCoordsForMap,
            deadheadPrevGeom, deadheadNextGeom
        );

    } catch(e) {
        showStatus('âŒ Fehler: ' + e.message, 'err');
        log('âŒ Fehler: ' + e.message, 'err');
        console.error(e);
    }

    btn.disabled = false;
    btn.textContent = 'â–¶ Konflikt prÃ¼fen';
}

function showResult(conflict, slotDt, pickup, dest, driveMins, totalMins, prevRide, nextRide, dayRides) {
    const el = document.getElementById('result');
    const body = document.getElementById('result-body');
    el.style.display = 'block';

    const slotEnd = new Date(slotDt.getTime() + totalMins * 60000);
    const timeStr = slotDt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    const endStr  = slotEnd.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

    let html = '';
    if (!conflict) {
        el.className = 'card result-frei';
        html += `<div class="result-title">âœ… SLOT FREI</div>`;
    } else {
        el.className = 'card result-konflikt';
        html += `<div class="result-title">âŒ KONFLIKT</div>`;
    }

    html += `<div class="detail-row"><span class="detail-label">GewÃ¼nschter Slot</span><span class="detail-value">${slotDt.toLocaleDateString('de-DE')} ${timeStr}â€“${endStr} Uhr</span></div>`;
    html += `<div class="detail-row"><span class="detail-label">Strecke</span><span class="detail-value">${pickup} â†’ ${dest}</span></div>`;
    html += `<div class="detail-row"><span class="detail-label">Fahrtdauer</span><span class="detail-value">${driveMins} Min Fahrt + ${params.boarding+params.alighting} Min Ein/Aus = ${totalMins} Min gesamt</span></div>`;
    html += `<div class="detail-row"><span class="detail-label">Fahrten am Tag</span><span class="detail-value">${dayRides.length}</span></div>`;

    if (prevRide) {
        const pt = new Date(prevRide.pickupTimestamp || prevRide.pickupTime).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
        html += `<div class="detail-row"><span class="detail-label">Vorherige Fahrt</span><span class="detail-value">${pt} Uhr â€“ ${prevRide.pickup||'?'} â†’ ${prevRide.destination||'?'}</span></div>`;
    }
    if (nextRide) {
        const nt = new Date(nextRide.pickupTimestamp || nextRide.pickupTime).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
        html += `<div class="detail-row"><span class="detail-label">NÃ¤chste Fahrt</span><span class="detail-value">${nt} Uhr â€“ ${nextRide.pickup||'?'} â†’ ${nextRide.destination||'?'}</span></div>`;
    }

    if (conflict) {
        html += `<div class="detail-row"><span class="detail-label">Konflikt-Typ</span><span class="detail-value" style="color:#ef4444;">${conflict.msg}</span></div>`;

        if (conflict.type === 'prev_gap' && conflict.earliestTs) {
            const earliest = new Date(conflict.earliestTs).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
            html += `<div class="detail-row"><span class="detail-label">FrÃ¼hestens mÃ¶glich</span><span class="detail-value" style="color:#10b981;">${earliest} Uhr</span></div>`;
            html += `<div style="margin-top:10px;"><button class="alt-btn alt-after" onclick="fillTime('${earliest}')">â–¶ ${earliest} Uhr testen</button></div>`;
        }

        if (conflict.type === 'next_gap') {
            if (conflict.beforeAlt) {
                const ba = conflict.beforeAlt.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
                html += `<div class="detail-row"><span class="detail-label">VORHER mÃ¶glich bis</span><span class="detail-value" style="color:#f59e0b;">${ba} Uhr</span></div>`;
                html += `<div style="margin-top:10px;">`;
                html += `<button class="alt-btn alt-before" onclick="fillTime('${ba}')">â¬… ${ba} Uhr testen</button>`;
            }
            if (nextRide) {
                const nt = new Date(nextRide.pickupTimestamp || nextRide.pickupTime);
                const afterMins = (nextRide.duration || 20) + params.boarding + params.alighting;
                const afterTs = nt.getTime() + afterMins * 60000;
                const after5 = new Date(Math.ceil(afterTs / (5*60000)) * (5*60000));
                const afterStr = after5.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
                html += `<button class="alt-btn alt-after" onclick="fillTime('${afterStr}')">â–¶ ${afterStr} Uhr testen</button>`;
                html += `</div>`;
            }
        }

        if (conflict.deadhead) {
            html += `<div class="detail-row"><span class="detail-label">Leerfahrt</span><span class="detail-value">${conflict.deadhead} Min</span></div>`;
        }
    }

    body.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HILFSFUNKTIONEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fillTime(timeStr) {
    document.getElementById('in-time').value = timeStr;
    runCheck();
}

function fillFromLog() {
    document.getElementById('in-date').value = '2026-03-02';
    document.getElementById('in-time').value = '06:15';
    document.getElementById('in-pickup').value = 'Amselring 10, Heringsdorf';
    document.getElementById('in-dest').value = 'LabahnstraÃŸe 18, Heringsdorf';
    log('ğŸ“‹ Log-Beispiel geladen: 02.03.2026 06:15', 'info');
}

function toggleSection(id) {
    const body = document.getElementById(id + '-body');
    const arrow = document.getElementById(id + '-arrow');
    const hidden = body.style.display === 'none';
    body.style.display = hidden ? '' : 'none';
    arrow.textContent = hidden ? 'â–¼' : 'â–¶';
}

// Datum auf heute vorbelegen
document.getElementById('in-date').value = getLocalDateString(new Date());
</script>
</body>
</html>
